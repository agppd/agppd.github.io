---
layout: post
title: "C++模板分享——单向ADT链表"
date: 2026-02-26
categories: 数据结构
author: agppd
---

发现没有单向链表，只有双向（stl 的 `list`），我也写一个

```cpp
/*
    Self made list, 
    Not for stl 
    
    这是一份线性表，但不符合stl的标准
*/
#ifndef XIANXINGBIAO_H
#define XIANXINGBIAO_H

#define ADD_SIZE 10
#define LENGTH 128

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

namespace XIANXINGBIAO
{

template <typename T>
class list
{
private:
    struct Node
    {
        T *elem;   // 存储用指针
        int length;// 当前长度
        int listsize;// 当前分配的存储容量（以sizeof(T)为单位）
    } L;

public:
    /* 构造函数：初始化线性表 */
    list()
    {
        L.elem=(T*)malloc(ADD_SIZE * sizeof(T));
        assert(L.elem);
        L.length=0;
        L.listsize=ADD_SIZE;
    }

    /* 析构函数：释放内存 */
    ~list()
    {
        if(L.elem)
        {
            free(L.elem);
            L.elem=nullptr;
        }
        L.length=0;
        L.listsize=0;
    }

    /* 初始条件:线性表L已存在。 */
    /* 操作结果:销毁线性表L。 */
    void del()
    {
        assert(L.elem);
        free(L.elem);
        L.elem=nullptr;
        L.length=0;
        L.listsize=0;
    }

    /* 初始条件:线性表L已存在。 */
    /* 操作结果:将L置为空表。 */
    void clear(){L.length=0;}

    /* 初始条件:线性表L已存在。 */
    /* 操作结果:若L为空，则返回TRUE，否则返回FALSE。 */
    bool empty(){return(L.length==0);}

    /* 初始条件:线性表L已存在。 */
    /* 操作结果:返回L中数据元素个数。同length */
    int size(){return L.length;}

    /* 初始条件:线性表L已存在。 */
    /* 操作结果:返回L中数据元素个数。同size */
    int length(){return L.length;}

    /* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */
    /* 操作结果:返回L中第i个元素的值。 */
    T ask(int id)
    {
        assert(!(id<1 or id>length));
        return L.elem[id-1];
    }

    /* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */
    /* 操作结果:用e返回L中第i个元素的值。 */
    bool ask(int id,T& ret)
    {
        if(id<1 or id>L.length) return false;
        ret=L.elem[id-1];
        return true;
    }

    /* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */
    /* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回0。 */
    int compare_find(T e,bool(*compare)(T,T))
    {
        for(int i=0;i<L.length;i++)
        {
            if(compare(L.elem[i],e)) return i+1;
        }
        return 0;
    }

    /* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */
    /* 操作结果：判断L中是否存在与e满足关系compare()的数据元素。若存在，则返回true，否则返回false。 */
    bool compare_pd(T e,bool(*compare)(T,T))
    {
        return(compare_find(e,compare) != 0);
    }

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回它的前驱，否则操作失败。 */
    T pre_find(T cur_e)
    {
        for(int i=1;i<L.length;i++)
        {
            if(L.elem[i]==cur_e)
            {
                return L.elem[i-1];
            }
        }
        std::cerr<<"Not found!"<<'\n';
        exit(1);
    }

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回true，否则返回false。 */
    bool pre_pd(T cur_e)
    {
        for(int i=1;i<L.length;i++)
        {
            if(L.elem[i]==cur_e)
            {
                return true;
            }
        }
        return false;
    }

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回它的后继，否则操作失败。 */
    T nxt_find(T cur_e)
    {
        for(int i=0;i<L.length-1;i++)
        {
            if(L.elem[i]==cur_e) return L.elem[i+1];
        }
        std::cerr<<"Not found!"<<'\n';
        exit(1);
    }

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回true，否则返回false。 */
    bool nxt_pd(T cur_e)
    {
        for(int i=0;i<L.length-1;i++)
        {
            if(L.elem[i]==cur_e)
            {
                return true;
            }
        }
        return false;
    }

    /* 初始条件：线性表L已存在,1≤i≤ListLength(L)+1。 */
    /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。 */
    void insert(int i,T e)
    {
        assert(!(i<1 or i>L.length+1))
        if(L.length>=L.listsize)
        {
            T* new_elem=(T*)realloc(L.elem,(L.listsize+LENGTH) * sizeof(T));
            assert(new_elem);
            L.elem=new_elem;
            L.listsize+=LENGTH;
        }
        for(int j=L.length;j>=i;j--)
        {
            L.elem[j]=L.elem[j-1];
        }
        L.elem[i-1]=e;
        L.length++;
    }

    /* 初始条件：线性表L已存在且非空，1≤i≤ListLength(L)。 */
    /* 操作结果：删除L的第i个数据元素，L的长度减1。 */
    void del(int i)
    {
        assert(!(i<1 || i>L.length))
        for(int j=i;j<L.length;j++)
        {
            L.elem[j-1]=L.elem[j];
        }
        L.length--;
    }

    /* 初始条件：线性表L已存在。 */
    /* 目的：遍历整个线性表L。 */
    /* 操作结果:依次对L的每个数据元素调用函数visit()。 */
    void bl(void(*visit)(T))
    {
        for(int i=0;i<L.length;i++)
        {
            visit(L.elem[i]);
        }
    }

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：返回线性表L的起始位置（索引0） */
    int begin(){return 0;}

    /* 初始条件：线性表L已存在。 */
    /* 操作结果：返回线性表L的结尾位置（索引length-1） */
    int end(){return L.length-1;}

    /* 初始条件：线性表长度已存在 */
    /* 操作结果：从输入读入，创建一个从0开始的新线性表,cin读入 */
    void read(int N)
    {
        for(int i=0;i<N;i++)
        {
            T x;
            std::cin >> x;
            insert(L.length+1,x);
        }
    }

    /* 初始条件：线性表已存在 */
    /* 操作结果：正序遍历线性表，以空格分开，cout输出 */
    void outF_()
    {
        for(int i=0;i<L.length;i++)
        {
            std::cout<<L.elem[i]<<' ';
        }
        std::cout<<'\n';
    }

    /* 初始条件：线性表已存在 */
    /* 操作结果：正序遍历线性表，以换行分开，cout输出 */
    void outFn()
    {
        for(int i=0;i<L.length;i++)  std::cout<<L.elem[i]<<'\n';
    }

    /* 初始条件：线性表已存在 */
    /* 操作结果：倒序遍历线性表，以空格分开，cout输出 */
    void outD_()
    {
        for(int i=L.length-1;i>=0;i--) std::cout<<L.elem[i]<<' ';
    }

    /* 初始条件：线性表已存在 */
    /* 操作结果：倒序遍历线性表，以换行分开，cout输出 */
    void outDn()
    {
        for(int i=L.length-1;i>=0;i--) std::cout<<L.elem[i]<<'\n';
    }
    
};

} // namespace XIANXINGBIAO

using namespace XIANXINGBIAO;

#endif
```