---
layout: post
title: "KMP算法详解"
date: 2026-03-01
categories: [理论,算法]
author: _endl_
---

## 问题
给定一个模式串 $s$ 和一个文本串 $t$，求模式串在文本串里出现过的次数。

## 约定
为了方便，下文称 $next_i$ 表示字符串 $s_0..s_i$ 的最长 $border$，$m=|s|，n=|t|$。

## 暴力做法
两个指针 $i,j$，用 $s_i$ 和 $t_j$ 匹配，如果相等，i++，j++，否则 i = 0，j=j-i+1。时间复杂度 $O(nm)$。

## 进一步的思考
我们会发现 $s_i \neq t_j$ 时，指针回退会导致大量重复比较。

但如果我们让 $j$ 只往右走就会避免重复比较。

考虑当前 $s_0..s_{i-1}$ 和 $t_0..t_{j-1}$ 已经匹配，我们如果能知道 $s_0..s_{i-1}$ 的最长 $border$，就可以直接让 $i$ 跳过去。

现在的问题在于求出 $next$ 数组。在网上有很多方法，这里给出一种比较好写好想的方法。

具体地：遍历模式串，令 j 为当前 $border$ 长度。

当 $j > 0$ 且 $s_i \neq s_j$ 时，反复令 $j = next[j-1]$（不断回退，直到 $j = 0$ 或 $s_i = s_j$）。

如果 $s_i = s_j$，则 $j$ 增加 1（即 $j = j + 1$）。

令 $next[i] = j$。

$next$ 预处理好了，接下来是较为具体的 $KMP$ 匹配过程：

首先 $i$ 指针用于遍历模式串，$j$ 遍历文本串，$ans$ 记录答案。

1. 如果匹配成功，i++,j++
2. 如果 i = m，即匹配完成，ans++,i = next[i-1]
3. 如果匹配失败
   - 若 i > 0，则 i = next[i-1]
   - 若 i = 0，则 j++

## 复杂度分析
预处理 $next$：$O(m)$
匹配：$O(n)$
总复杂度：$O(n+m)$