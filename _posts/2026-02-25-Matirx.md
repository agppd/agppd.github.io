---
layout: post
title: "C++模板分享——矩阵"
date: 2026-02-25
categories: [数据结构,模板]
author: agppd
---

```cpp
class Node
{
    private:
    size_t n,m;
    size_t mp[N][N];
    public:
    Node(size_t x,size_t y)
    {
        n=x;
        m=y;
        memset(mp,0,sizeof(mp));
    }
    Node()
    {
        n=0,m=0,memset(mp,0,sizeof(mp));
    }
    Node(size_t x)
    {
        n=m=x;memset(mp,0,sizeof(mp));
    }
    Node(const vector<vector<size_t>>& v)
    {
        if(v.empty())
        {
            n = m = 0;
            memset(mp, 0, sizeof(mp));
            return;
        }
        n = v.size();
        m = v[0].size();
        memset(mp, 0, sizeof(mp));
        for(size_t i=0; i<n and i+1<N; i++)
        {
            for(size_t j=0; j<m and j+1<N; j++)
            {
                mp[i+1][j+1] = v[i][j];
            }
        }
    }
    Node(const Node& other)
    {
        n = other.n;
        m = other.m;
        memcpy(mp, other.mp, sizeof(mp));
    }
    size_t query(size_t x,size_t y)
    {
        return mp[x][y];
    }
    void unit()
    {
        if(n!=m) 
        {
            cerr<<"This is not a square. Check your init function. "<<'\n';
            return;
        }
        memset(mp,0,sizeof(mp));
        for(size_t i=1;i<=n;i++)
            mp[i][i]=1;
        return ;
    }
    
    Node& operator=(const Node& other)
    {
        if(this != &other)
        {
            n = other.n;
            m = other.m;
            memcpy(mp, other.mp, sizeof(mp));
        }
        return *this;
    }
    
    Node operator*(const Node &x) const
    {
        if(m != x.n)
        {
            cerr << "Matrix dimensions do not match for multiplication!" << '\n';
            return Node();
        }
        
        size_t p=x.m;
        Node res(n,p);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=p;j++)
            {
                long long sum = 0; 
                for(size_t k=1;k<=m;k++)
                {
                    sum += (1LL * mp[i][k] * x.mp[k][j]) % mod;
                    if(sum >= mod) sum -= mod;
                }
                res.mp[i][j] = sum % mod;
            }
        }
        return res;
    }
    
    void pow(long long k)
    {
        if(n != m)
        {
            cerr << "Cannot exponentiate non-square matrix!" << '\n';
            return;
        }
        Node result(n);
        result.unit();
        Node base = *this;
        long long exp = k;
        while(exp > 0)
        {
            if(exp & 1) result = result * base;
            base = base * base;
            exp >>= 1;
        }
        *this = result;
    }
    
    Node operator+(const Node &x) const
    {
        if(n != x.n || m != x.m)
        {
            cerr << "Matrix dimensions do not match for addition!" << '\n';
            return Node();
        }
        
        Node res(n,m);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=m;j++)
            {
                res.mp[i][j] = (mp[i][j] + x.mp[i][j]) % mod;
            }
        }
        return res;
    }
    
    Node operator-(const Node &x) const
    {
        if(n != x.n || m != x.m)
        {
            cerr << "Matrix dimensions do not match for subtraction!" << '\n';
            return Node();
        }
        
        Node res(n,m);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=m;j++)
            {
                res.mp[i][j] = (mp[i][j] - x.mp[i][j] + mod) % mod;
            }
        }
        return res;
    }
    
    bool operator==(const Node &x) const
    {
        if(n!=x.n || m!=x.m) return false;
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=m;j++)
            {
                if(mp[i][j]!=x.mp[i][j])
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    void operator +=(const Node &x)
    {
        *this = *this + x;
    }
    
    void operator -=(const Node &x)
    {
        *this = *this - x;
    }
    
    void operator *=(const Node &x)
    {
        *this = *this * x;
    }

    Node operator^(const Node &x) const
    {
        if(m != x.n)
        {
            cerr << "Matrix dimensions do not match for bitwise XOR!" << '\n';
            return Node();
        }
        
        size_t p=x.m;
        Node res(n,p);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=p;j++)
            {
                for(size_t k=1;k<=m;k++)
                {
                    res.mp[i][j] += mp[i][k] ^ x.mp[k][j];
                }
            }
        }
        return res;
    }

    Node operator&(const Node &x) const
    {
        if(m != x.n)
        {
            cerr << "Matrix dimensions do not match for bitwise AND!" << '\n';
            return Node();
        }
        
        size_t p=x.m;
        Node res(n,p);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=p;j++)
            {
                for(size_t k=1;k<=m;k++)
                {
                    res.mp[i][j] += mp[i][k] & x.mp[k][j];
                }
            }
        }
        return res;
    }

    Node operator|(const Node &x) const
    {
        if(m != x.n)
        {
            cerr << "Matrix dimensions do not match for bitwise OR!" << '\n';
            return Node();
        }
        
        size_t p=x.m;
        Node res(n,p);
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=p;j++)
            {
                for(size_t k=1;k<=m;k++)
                {
                    res.mp[i][j] += mp[i][k] | x.mp[k][j];
                }
            }
        }
        return res;
    }

    void operator ^=(const Node &x)
    {
        *this = *this ^ x;
    }

    void operator &=(const Node &x)
    {
        *this = *this & x;
    }

    void operator |=(const Node &x)
    {
        *this = *this | x;
    }
    
    void input()
    {
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=m;j++)
            {
                cin>>mp[i][j];
            }
        }
    }
    
    void prsize_t() const
    {
        for(size_t i=1;i<=n;i++)
        {
            for(size_t j=1;j<=m;j++)
            {
                size_t val = (mp[i][j] % mod + mod) % mod;
                cout << val;
                if(j < m) cout << ' ';
            }
            cout << '\n';
        }
    }
};
```