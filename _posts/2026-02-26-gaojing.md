---
layout: post
title: "C++模板分享——高精度"
date: 2026-02-26
categories: 模板
author: agppd
---
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <stdexcept>
#include <climits>
#include <cctype>
using namespace std;
namespace gaojing {

class BigInt {
private:
    std::vector<int> digits;  // ´æ´¢Êý×Ö£¨ÄæÐò£º¸öÎ»ÔÚdigits[0]£©
    bool isNegative;          // ·ûºÅ±ê¼Ç

    // ÒÆ³ýÇ°µ¼Áã²¢´¦Àí½á¹ûÎª0µÄÇé¿ö
    void removeLeadingZeros() {
        while (digits.size() > 1 && digits.back() == 0) {
            digits.pop_back();
        }
        if (digits.size() == 1 && digits[0] == 0) {
            isNegative = false;  // -0 ÊÓÎª 0
        }
    }

    // ±È½Ï¾ø¶ÔÖµ´óÐ¡£¨ºöÂÔ·ûºÅ£©
    int compareAbs(const BigInt& other) const {
        if (digits.size() != other.digits.size()) {
            return digits.size() > other.digits.size() ? 1 : -1;
        }
        for (int i = digits.size() - 1; i >= 0; --i) {
            if (digits[i] != other.digits[i]) {
                return digits[i] > other.digits[i] ? 1 : -1;
            }
        }
        return 0;
    }

public:
    // ¹¹Ôìº¯Êý
    BigInt() : digits(1, 0), isNegative(false) {}
    
    // ´Ó×Ö·û´®¹¹Ôì
    BigInt(const std::string& s) {
        if (s.empty()) {
            digits.push_back(0);
            isNegative = false;
            return;
        }

        int start = 0;
        if (s[0] == '-') {
            isNegative = true;
            start = 1;
        } else {
            isNegative = false;
            if (s[0] == '+') start = 1;
        }

        // ´Ó×Ö·û´®Ä©Î²¿ªÊ¼½âÎö£¨¸öÎ»¿ªÊ¼£©
        for (int i = s.size() - 1; i >= start; --i) {
            if (!isdigit(s[i])) throw std::invalid_argument("Invalid character in number");
            digits.push_back(s[i] - '0');
        }
        removeLeadingZeros();
    }

    // ´ÓÕûÐÍ¹¹Ôì
    BigInt(long long num) {
        if (num < 0) {
            isNegative = true;
            num = -num;
        } else {
            isNegative = false;
        }

        if (num == 0) {
            digits.push_back(0);
            return;
        }

        while (num > 0) {
            digits.push_back(num % 10);
            num /= 10;
        }
    }

    // ×ª»»Îª×Ö·û´®
    std::string toString() const {
        std::string str;
        if (isNegative && !(digits.size() == 1 && digits[0] == 0)) {
            str += '-';
        }
        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {
            str += char('0' + *it);
        }
        return str;
    }

    // ×ª»»ÎªÕûÐÍ£¨¿ÉÄÜ¶ªÊ§¾«¶È»òÒç³ö£©
    long long toLongLong() const {
        long long num = 0;
        long long power = 1;
        
        for (size_t i = 0; i < digits.size(); ++i) {
            // ¼ì²éÒç³ö
            if (digits[i] > 0 && i >= 19) { // ³¬¹ýLLONG_MAXµÄÎ»Êý
                throw std::overflow_error("BigInt too large for long long");
            }
            
            num += static_cast<long long>(digits[i]) * power;
            
            // ¼ì²éÖÐ¼ä½á¹ûÒç³ö
            if (i < digits.size() - 1) {
                if (num > LLONG_MAX / 10) {
                    throw std::overflow_error("BigInt too large for long long");
                }
            }
            
            power *= 10;
        }
        
        return isNegative ? -num : num;
    }

    // ¼Ó·¨
    BigInt operator+(const BigInt& other) const {
        if (isNegative == other.isNegative) {
            BigInt result;
            result.isNegative = isNegative;
            result.digits.resize(std::max(digits.size(), other.digits.size()) + 1, 0);

            int carry = 0;
            for (size_t i = 0; i < result.digits.size(); ++i) {
                int a = (i < digits.size()) ? digits[i] : 0;
                int b = (i < other.digits.size()) ? other.digits[i] : 0;
                int sum = a + b + carry;
                result.digits[i] = sum % 10;
                carry = sum / 10;
            }

            result.removeLeadingZeros();
            return result;
        } else {
            if (isNegative) {
                return other - (-*this);
            } else {
                return *this - (-other);
            }
        }
    }

    // ÓëÕûÐÍ¼Ó·¨
    BigInt operator+(long long other) const {
        return *this + BigInt(other);
    }

    // ÕûÐÍ¼Ó·¨£¨È«¾Öº¯Êý£©
    friend BigInt operator+(long long lhs, const BigInt& rhs) {
        return BigInt(lhs) + rhs;
    }

    // ¼õ·¨
    BigInt operator-(const BigInt& other) const {
        if (isNegative != other.isNegative) {
            return *this + (-other);
        }

        BigInt result;
        const BigInt *a = this, *b = &other;
        
        if (compareAbs(other) < 0) {
            std::swap(a, b);
            result.isNegative = !isNegative;
        } else {
            result.isNegative = isNegative;
        }

        result.digits.resize(a->digits.size(), 0);
        int borrow = 0;
        for (size_t i = 0; i < result.digits.size(); ++i) {
            int top = a->digits[i];
            int bottom = (i < b->digits.size()) ? b->digits[i] : 0;
            int diff = top - bottom - borrow;
            
            if (diff < 0) {
                diff += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            
            result.digits[i] = diff;
        }

        result.removeLeadingZeros();
        return result;
    }

    // ÓëÕûÐÍ¼õ·¨
    BigInt operator-(long long other) const {
        return *this - BigInt(other);
    }

    // ÕûÐÍ¼õ·¨£¨È«¾Öº¯Êý£©
    friend BigInt operator-(long long lhs, const BigInt& rhs) {
        return BigInt(lhs) - rhs;
    }

    // ³Ë·¨
    BigInt operator*(const BigInt& other) const {
        BigInt result;
        result.digits.resize(digits.size() + other.digits.size(), 0);
        result.isNegative = isNegative ^ other.isNegative;

        for (size_t i = 0; i < digits.size(); ++i) {
            int carry = 0;
            for (size_t j = 0; j < other.digits.size() || carry; ++j) {
                long long product = result.digits[i + j] + 
                                   static_cast<long long>(digits[i]) * 
                                   (j < other.digits.size() ? other.digits[j] : 0) + 
                                   carry;
                result.digits[i + j] = product % 10;
                carry = product / 10;
            }
        }

        result.removeLeadingZeros();
        return result;
    }

    // ÓëÕûÐÍ³Ë·¨
    BigInt operator*(long long other) const {
        return *this * BigInt(other);
    }

    // ÕûÐÍ³Ë·¨£¨È«¾Öº¯Êý£©
    friend BigInt operator*(long long lhs, const BigInt& rhs) {
        return BigInt(lhs) * rhs;
    }

    // ³ý·¨
    BigInt operator/(const BigInt& divisor) const {
        if (divisor == BigInt(0)) {
            throw std::runtime_error("Division by zero");
        }
        
        BigInt quotient, remainder;
        quotient.digits.resize(digits.size(), 0);
        quotient.isNegative = isNegative ^ divisor.isNegative;
        
        BigInt absDivisor = divisor.abs();
        remainder = BigInt(0);
        
        for (int i = digits.size() - 1; i >= 0; --i) {
            remainder = remainder * BigInt(10) + BigInt(digits[i]);
            int count = 0;
            while (remainder >= absDivisor) {
                remainder = remainder - absDivisor;
                count++;
            }
            quotient.digits[i] = count;
        }
        
        quotient.removeLeadingZeros();
        return quotient;
    }

    // ÓëÕûÐÍ³ý·¨
    BigInt operator/(long long other) const {
        return *this / BigInt(other);
    }

    // ÕûÐÍ³ý·¨£¨È«¾Öº¯Êý£©
    friend BigInt operator/(long long lhs, const BigInt& rhs) {
        return BigInt(lhs) / rhs;
    }

    // È¡¸º
    BigInt operator-() const {
        BigInt result = *this;
        if (*this != BigInt(0)) {
            result.isNegative = !isNegative;
        }
        return result;
    }

    // ¾ø¶ÔÖµ
    BigInt abs() const {
        BigInt result = *this;
        result.isNegative = false;
        return result;
    }

    // ±È½ÏÔËËã·û
    bool operator<(const BigInt& other) const {
        if (isNegative != other.isNegative) {
            return isNegative;
        }
        
        int cmp = compareAbs(other);
        return isNegative ? cmp > 0 : cmp < 0;
    }

    bool operator>(const BigInt& other) const { return other < *this; }
    bool operator<=(const BigInt& other) const { return !(other < *this); }
    bool operator>=(const BigInt& other) const { return !(*this < other); }
    
    bool operator==(const BigInt& other) const {
        return isNegative == other.isNegative && digits == other.digits;
    }
    
    bool operator!=(const BigInt& other) const { return !(*this == other); }

    // ÓëÕûÐÍ±È½Ï
    bool operator<(long long other) const { return *this < BigInt(other); }
    bool operator>(long long other) const { return *this > BigInt(other); }
    bool operator<=(long long other) const { return *this <= BigInt(other); }
    bool operator>=(long long other) const { return *this >= BigInt(other); }
    bool operator==(long long other) const { return *this == BigInt(other); }
    bool operator!=(long long other) const { return *this != BigInt(other); }

    // ÕûÐÍ±È½Ï£¨È«¾Öº¯Êý£©
    friend bool operator<(long long lhs, const BigInt& rhs) { return BigInt(lhs) < rhs; }
    friend bool operator>(long long lhs, const BigInt& rhs) { return BigInt(lhs) > rhs; }
    friend bool operator<=(long long lhs, const BigInt& rhs) { return BigInt(lhs) <= rhs; }
    friend bool operator>=(long long lhs, const BigInt& rhs) { return BigInt(lhs) >= rhs; }
    friend bool operator==(long long lhs, const BigInt& rhs) { return BigInt(lhs) == rhs; }
    friend bool operator!=(long long lhs, const BigInt& rhs) { return BigInt(lhs) != rhs; }

    // Êä³öÔËËã·û
    friend std::ostream& operator<<(std::ostream& os, const BigInt& num) {
        return os << num.toString();
    }
};

} // namespace gaojing
using namespace gaojing;
```