<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-02-28T08:33:22+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">agppd团队 的博客</title><subtitle>个人运营的团队技术博客</subtitle><entry><title type="html">OpenGL系列转载教程三</title><link href="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/28/OpenGL3.html" rel="alternate" type="text/html" title="OpenGL系列转载教程三" /><published>2026-02-28T00:00:00+08:00</published><updated>2026-02-28T00:00:00+08:00</updated><id>http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/28/OpenGL3</id><content type="html" xml:base="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/28/OpenGL3.html"><![CDATA[<h3 id="声明">声明</h3>

<p>本系列教程均属于转载教程，经作者的整理与重新编写，如有侵权，请联系作者删除。
本篇转载自https://learnopengl-cn.github.io/</p>

<h2 id="一如何渲染">一、如何渲染</h2>

<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>

<p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。</p>

<p>GPU为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>

<p>有些着色器可以由开发者配置，因为允许用自己写的着色器来代替默认的，所以能够更细致地控制图形渲染管线中的特定部分了。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</p>

<p>图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。</p>

<p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而这样一个顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置和一些颜色值组成的吧。</p>

<h4 id="图元">图元</h4>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：<code class="language-plaintext highlighter-rouge">GL_POINTS</code>、<code class="language-plaintext highlighter-rouge">GL_TRIANGLES</code>、<code class="language-plaintext highlighter-rouge">GL_LINE_STRIP</code>。</p>

<p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>

<p>顶点着色器阶段的输出可以选择性地传递给几何着色器(Geometry Shader)。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。</p>

<p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状；本节例子中是两个三角形。</p>

<p>图元装配阶段的输出会被传入<strong>光栅化阶段</strong>(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的<strong>片段</strong>(Fragment)。在片段着色器运行之前会执行<strong>裁切</strong>(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>

<p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>

<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<strong>Alpha测试</strong>和<strong>混合</strong>(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行<strong>混合</strong>(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>

<p>对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>

<h2 id="二顶点输入">二、顶点输入</h2>

<p>开始绘制图形之前，我们需要先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以在OpenGL中我们指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做<strong>标准化设备坐标</strong>(Normalized Device Coordinates)，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个数组。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
     <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>
     <span class="mf">0.0f</span><span class="p">,</span>  <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>
<span class="p">};</span>
</code></pre></div></div>

<p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p>

<p><img src="/assets/image/ndc.png" alt="" /></p>

<p>通过使用由<code class="language-plaintext highlighter-rouge">glViewport()</code>提供的数据，进行<strong>视口变换</strong>(Viewport Transform)，<strong>标准化设备坐标</strong>(Normalized Device Coordinates)会变换为<strong>屏幕空间坐标</strong>(Screen-space Coordinates)。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>

<p>我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</p>

<p>顶点缓冲对象是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用<code class="language-plaintext highlighter-rouge">glGenBuffers()</code>生成一个带有缓冲ID的VBO对象：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
</code></pre></div></div>
<p>OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用<code class="language-plaintext highlighter-rouge">glBindBuffer()</code>把新创建的缓冲绑定到<code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code>目标上：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>  
</code></pre></div></div>
<p>然后我们可以调用<code class="language-plaintext highlighter-rouge">glBufferData()</code>，它会把之前定义的顶点数据复制到缓冲的内存中：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">glBufferData()</code>是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code class="language-plaintext highlighter-rouge">sizeof</code>计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p>

<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>

<p><code class="language-plaintext highlighter-rouge">GL_STATIC_DRAW</code> ：数据不会或几乎不会改变。
<code class="language-plaintext highlighter-rouge">GL_DYNAMIC_DRAW</code>：数据会被改变很多。
<code class="language-plaintext highlighter-rouge">GL_STREAM_DRAW</code> ：数据每次绘制时都会改变。
三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是<code class="language-plaintext highlighter-rouge">GL_STATIC_DRAW</code>。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是<code class="language-plaintext highlighter-rouge">GL_DYNAMIC_DRAW</code>或<code class="language-plaintext highlighter-rouge">GL_STREAM_DRAW</code>，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>

<h2 id="三顶点着色器">三、顶点着色器</h2>

<p><strong>顶点着色器</strong>(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。下一节中我们会更详细的讨论着色器。</p>

<p>我们需要做的第一件事是用着色器语言<strong>GLSL</strong>(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 330 core
</span><span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>(注，<code class="language-plaintext highlighter-rouge">markdown</code>没有这种语言的高亮，只好用<code class="language-plaintext highlighter-rouge">c</code>了)</p>

<p>可以看到，GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</p>

<p>下一步，使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。</p>

<p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的<code class="language-plaintext highlighter-rouge">gl_Position</code>变量，它在幕后是<code class="language-plaintext highlighter-rouge">vec4</code>类型的。在<code class="language-plaintext highlighter-rouge">main</code>函数的最后，我们将<code class="language-plaintext highlighter-rouge">gl_Position</code>设置的值会成为该顶点着色器的输出。由于我们的输入是一个3分量的向量，我们必须把它转换为4分量的。我们可以把<code class="language-plaintext highlighter-rouge">vec3</code>的数据作为<code class="language-plaintext highlighter-rouge">vec4</code>构造器的参数，同时把<code class="language-plaintext highlighter-rouge">w</code>分量设置为<code class="language-plaintext highlighter-rouge">1.0f</code>（我们会在后面解释为什么）来完成这一任务。</p>

<p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内。</p>

<h2 id="四编译但不运行">四、编译但不运行</h2>

<p>现在，我们暂时将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vertexShaderSource</span> <span class="o">=</span> <span class="s">"#version 330 core</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"layout (location = 0) in vec3 aPos;</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"void main()</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"{</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"}</span><span class="se">\0</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div>
<p>为了能够让OpenGL使用它，我们必须在运行时动态编译它的源代码。</p>

<p>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为<code class="language-plaintext highlighter-rouge">unsigned int</code>，然后用<code class="language-plaintext highlighter-rouge">glCreateShader</code>创建这个着色器：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
<span class="n">vertexShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
</code></pre></div></div>
<p>我们把需要创建的着色器类型以参数形式提供给<code class="language-plaintext highlighter-rouge">glCreateShader</code>。由于我们正在创建一个顶点着色器，传递的参数是<code class="language-plaintext highlighter-rouge">GL_VERTEX_SHADER</code>。</p>

<p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">glShaderSource</code>函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为<code class="language-plaintext highlighter-rouge">NULL</code>。</p>

<h4 id="如何debug">如何debug</h4>
<p>你可能会希望检测在调用<code class="language-plaintext highlighter-rouge">glCompileShader</code>后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>  <span class="n">success</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
</code></pre></div></div>
<p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用<code class="language-plaintext highlighter-rouge">glGetShaderiv</code>检查是否编译成功。如果编译失败，我们会用<code class="language-plaintext highlighter-rouge">glGetShaderInfoLog</code>获取错误消息，然后打印它。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERROR::SHADER::VERTEX::COMPILATION_FAILED</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="五片段着色器">五、片段着色器</h2>

<p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 330 core
</span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。声明输出变量可以使用<code class="language-plaintext highlighter-rouge">out</code>关键字，这里我们命名为<code class="language-plaintext highlighter-rouge">FragColor</code>。下面，我们将一个Alpha值为1.0(1.0代表完全不透明)的橘黄色的<code class="language-plaintext highlighter-rouge">vec4</code>赋值给颜色输出。</p>

<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用<code class="language-plaintext highlighter-rouge">GL_FRAGMENT_SHADER</code>常量作为着色器类型。</p>

<p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的<strong>着色器程序</strong>(Shader Program)中。</p>

<h3 id="着色器程序">着色器程序</h3>
<p><strong>着色器程序对象</strong>(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们<strong>链接</strong>(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p>

<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p>

<p>创建一个程序对象很简单：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
<span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">glCreateProgram()</code>函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用<code class="language-plaintext highlighter-rouge">glLinkProgram()</code>链接它们：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</code></pre></div></div>
<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glGetProgramiv</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glGetProgramInfoLog</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>得到的结果就是一个程序对象，我们可以调用<code class="language-plaintext highlighter-rouge">glUseProgram()</code>，用刚创建的程序对象作为它的参数，以激活这个程序对象。
在<code class="language-plaintext highlighter-rouge">glUseProgram()</code>调用之后，每个着色器调用和渲染调用都会使用这个程序对象，也就是之前写的着色器了。</p>

<p>对了，在把着色器对象链接到程序对象以后，记得用<code class="language-plaintext highlighter-rouge">glDeleteShader()</code>删除着色器对象，我们不再需要它们了。</p>

<p>OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。</p>

<h2 id="六链接顶点属性">六、链接顶点属性</h2>

<p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p>

<p>我们的顶点缓冲数据会被解析为下面这样子：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>顶点1</th>
      <th>顶点2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>x y  z</td>
      <td>x  y  z</td>
    </tr>
    <tr>
      <td>bit</td>
      <td>4 8 12</td>
      <td>16 20 24</td>
    </tr>
  </tbody>
</table>

<p>位置数据被储存为32位（4字节）浮点值。
每个位置包含3个这样的值。
在这3个值之间没有空隙（或其他值）。这几个值在数组中<strong>紧密排列</strong>(Tightly Packed)。
数据中第一个值在缓冲开始的位置。
有了这些信息我们就可以使用<code class="language-plaintext highlighter-rouge">glVertexAttribPointer()</code>函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">glVertexAttribPointer</code>函数的参数非常多，所以我会逐一介绍它们：</p>

<p>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code class="language-plaintext highlighter-rouge">layout(location = 0)</code>定义了<code class="language-plaintext highlighter-rouge">position</code>顶点属性的<strong>位置值</strong>(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。</p>

<p>第二个参数指定顶点属性的大小。顶点属性是一个<code class="language-plaintext highlighter-rouge">vec3</code>，它由3个值组成，所以大小是3。</p>

<p>第三个参数指定数据的类型，这里是<code class="language-plaintext highlighter-rouge">GL_FLOAT</code>(GLSL中<code class="language-plaintext highlighter-rouge">vec*</code>都是由浮点数值组成的)。</p>

<p>下个参数定义我们是否希望数据被<strong>标准化</strong>(Normalize)。如果我们设置为<code class="language-plaintext highlighter-rouge">GL_TRUE</code>，所有数据都会被映射到0（对于有符号型<code class="language-plaintext highlighter-rouge">signed</code>数据是-1）到1之间。我们把它设置为<code class="language-plaintext highlighter-rouge">GL_FALSE</code>。</p>

<p>第五个参数叫做<strong>步长</strong>(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code class="language-plaintext highlighter-rouge">float</code>之后，我们把步长设置为<code class="language-plaintext highlighter-rouge">3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子。</p>

<p>最后一个参数的类型是<code class="language-plaintext highlighter-rouge">void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的<strong>偏移量</strong>(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</p>

<p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用<code class="language-plaintext highlighter-rouge">glEnableVertexAttribArray()</code>，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 0. 复制顶点数组到缓冲中供OpenGL使用</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="c1">// 1. 设置顶点属性指针</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// 2. 当我们渲染一个物体时要使用着色器程序</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="c1">// 3. 绘制物体</span>
<span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>
</code></pre></div></div>

<p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p>

<h2 id="七顶点数组对象">七、顶点数组对象</h2>

<p><strong>顶点数组对象</strong>(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p>

<p>一个顶点数组对象会储存以下这些内容：</p>

<p><code class="language-plaintext highlighter-rouge">glEnableVertexAttribArray</code>和<code class="language-plaintext highlighter-rouge">glDisableVertexAttribArray</code>的调用。
通过<code class="language-plaintext highlighter-rouge">glVertexAttribPointer</code>设置的顶点属性配置。
通过<code class="language-plaintext highlighter-rouge">glVertexAttribPointer</code>调用与顶点属性关联的顶点缓冲对象。</p>

<p>创建一个VAO和创建一个VBO很类似：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span><span class="p">;</span>
<span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</code></pre></div></div>
<p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span>
<span class="c1">// 1. 绑定VAO</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="c1">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="c1">// 3. 设置顶点属性指针</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">[...]</span>

<span class="c1">// ..:: 绘制代码（渲染循环中） :: ..</span>
<span class="c1">// 4. 绘制物体</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>
</code></pre></div></div>
<p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针），然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p>

<h2 id="八我们一直期待的三角形">八、我们一直期待的三角形</h2>

<p>要想绘制我们想要的物体，OpenGL给我们提供了<code class="language-plaintext highlighter-rouge">glDrawArrays</code>函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">glDrawArrays</code>函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递<code class="language-plaintext highlighter-rouge">GL_TRIANGLES</code>给它。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</p>

<p>现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果：</p>

<p><img src="/assets/image/hellotriangle.png" alt="一个橘色三角形" /></p>

<p>完整的程序源码可以在<a href="/assets/file/hellotriangle.cpp">这里</a>找到。</p>

<p>如果你的输出和这个看起来不一样，你可能做错了什么。去查看一下源码，检查你是否遗漏了什么东西，或者你也可以在评论区提问。</p>

<h2 id="九元素缓冲对象">九、元素缓冲对象</h2>

<p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西——<strong>元素缓冲对象</strong>(Element Buffer Object，EBO)，也叫<strong>索引缓冲对象</strong>(Index Buffer Object，IBO)。要解释元素缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 第一个三角形</span>
    <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// 右上角</span>
    <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// 右下角</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// 左上角</span>
    <span class="c1">// 第二个三角形</span>
    <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// 右下角</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="c1">// 左下角</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>   <span class="c1">// 左上角</span>
<span class="p">};</span>
</code></pre></div></div>
<p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？</p>

<p>值得庆幸的是，元素缓冲区对象的工作方式正是如此。 EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。这种所谓的<strong>索引绘制</strong>(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>   <span class="c1">// 右上角</span>
    <span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span>  <span class="c1">// 右下角</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="c1">// 左下角</span>
    <span class="o">-</span><span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="mf">0.0f</span>   <span class="c1">// 左上角</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 注意索引从0开始! </span>
    <span class="c1">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span>
    <span class="c1">// 这样可以由下标代表顶点组合成矩形</span>

    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// 第一个三角形</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1">// 第二个三角形</span>
<span class="p">};</span>
</code></pre></div></div>
<p>你可以看到，当使用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建元素缓冲对象：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span>
</code></pre></div></div>
<p>与VBO类似，我们先绑定EBO然后用<code class="language-plaintext highlighter-rouge">glBufferData</code>把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为<code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</code></pre></div></div>
<p>注意：我们传递了<code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>当作缓冲目标。最后一件要做的事是用<code class="language-plaintext highlighter-rouge">glDrawElements</code>来替换<code class="language-plaintext highlighter-rouge">glDrawArrays</code>函数，表示我们要从索引缓冲区渲染三角形。使用<code class="language-plaintext highlighter-rouge">glDrawElements</code>时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>
<p>第一个参数指定了我们绘制的模式，这个和<code class="language-plaintext highlighter-rouge">glDrawArrays</code>的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是<code class="language-plaintext highlighter-rouge">GL_UNSIGNED_INT</code>。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p>

<p><code class="language-plaintext highlighter-rouge">glDrawElements</code>函数从当前绑定到<code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>目标的EBO中获取其索引。这意味着我们每次想要使用索引渲染对象时都必须绑定相应的EBO，这又有点麻烦。碰巧顶点数组对象也跟踪元素缓冲区对象绑定。在绑定VAO时，绑定的最后一个元素缓冲区对象存储为VAO的元素缓冲区对象。然后，绑定到VAO也会自动绑定该EBO。</p>

<p>最后的初始化和绘制代码现在看起来像这样：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ..:: 初始化代码 :: ..</span>
<span class="c1">// 1. 绑定顶点数组对象</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="c1">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="c1">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="c1">// 4. 设定顶点属性指针</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">[...]</span>

<span class="c1">// ..:: 绘制代码（渲染循环中） :: ..</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用<strong>线框模式</strong>(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。
<img src="/assets/image/hellotriangle2.png" alt="一个实心矩形和一个空心，有一条对角线的矩形" /></p>

<p><strong>线框模式(Wireframe Mode)</strong></p>

<p>要想用线框模式绘制你的三角形，你可以通过<code class="language-plaintext highlighter-rouge">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code class="language-plaintext highlighter-rouge">glPolygonMode</code><code class="language-plaintext highlighter-rouge">(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p>

<p>如果你像我这样成功绘制出了这个三角形或矩形，那么恭喜你，你成功地通过了现代OpenGL最难部分之一：绘制你自己的第一个三角形。这部分很难，因为在可以绘制第一个三角形之前你需要了解很多知识。幸运的是我们现在已经越过了这个障碍，接下来的教程会比较容易理解一些。</p>]]></content><author><name>fbf</name></author><category term="OpenGL系列" /><summary type="html"><![CDATA[声明 本系列教程均属于转载教程，经作者的整理与重新编写，如有侵权，请联系作者删除。 本篇转载自https://learnopengl-cn.github.io/ 一、如何渲染 在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。 图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。 GPU为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。 有些着色器可以由开发者配置，因为允许用自己写的着色器来代替默认的，所以能够更细致地控制图形渲染管线中的特定部分了。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。 图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。 首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而这样一个顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置和一些颜色值组成的吧。 图元 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。 顶点着色器阶段的输出可以选择性地传递给几何着色器(Geometry Shader)。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。 图元装配(Primitive Assembly)阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状；本节例子中是两个三角形。 图元装配阶段的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。 二、顶点输入 开始绘制图形之前，我们需要先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以在OpenGL中我们指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做标准化设备坐标(Normalized Device Coordinates)，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个数组。 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。 通过使用由glViewport()提供的数据，进行视口变换(Viewport Transform)，标准化设备坐标(Normalized Device Coordinates)会变换为屏幕空间坐标(Screen-space Coordinates)。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。 顶点缓冲对象是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers()生成一个带有缓冲ID的VBO对象： unsigned int VBO; glGenBuffers(1, &amp;VBO); OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer()把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上： glBindBuffer(GL_ARRAY_BUFFER, VBO); 然后我们可以调用glBufferData()，它会把之前定义的顶点数据复制到缓冲的内存中： glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData()是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。 三、顶点着色器 顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。下一节中我们会更详细的讨论着色器。 我们需要做的第一件事是用着色器语言GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码： #version 330 core layout (location = 0) in vec3 aPos; void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); } (注，markdown没有这种语言的高亮，只好用c了) 可以看到，GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。 下一步，使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。 为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的gl_Position变量，它在幕后是vec4类型的。在main函数的最后，我们将gl_Position设置的值会成为该顶点着色器的输出。由于我们的输入是一个3分量的向量，我们必须把它转换为4分量的。我们可以把vec3的数据作为vec4构造器的参数，同时把w分量设置为1.0f（我们会在后面解释为什么）来完成这一任务。 当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内。 四、编译但不运行 现在，我们暂时将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中 const char *vertexShaderSource = "#version 330 core\n" "layout (location = 0) in vec3 aPos;\n" "void main()\n" "{\n" " gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n" "}\0"; 为了能够让OpenGL使用它，我们必须在运行时动态编译它的源代码。 我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器： unsigned int vertexShader; vertexShader = glCreateShader(GL_VERTEX_SHADER); 我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。 下一步我们把这个着色器源码附加到着色器对象上，然后编译它： glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL。 如何debug 你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现： int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); 首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。 if(!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; } 五、片段着色器 片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。 #version 330 core out vec4 FragColor; void main() { FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f); } 片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。声明输出变量可以使用out关键字，这里我们命名为FragColor。下面，我们将一个Alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。 编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型。 两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。 着色器程序 着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。 创建一个程序对象很简单： unsigned int shaderProgram; shaderProgram = glCreateProgram(); glCreateProgram()函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram()链接它们： glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); 就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。 glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ... } 得到的结果就是一个程序对象，我们可以调用glUseProgram()，用刚创建的程序对象作为它的参数，以激活这个程序对象。 在glUseProgram()调用之后，每个着色器调用和渲染调用都会使用这个程序对象，也就是之前写的着色器了。 对了，在把着色器对象链接到程序对象以后，记得用glDeleteShader()删除着色器对象，我们不再需要它们了。 OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。 六、链接顶点属性 顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。 我们的顶点缓冲数据会被解析为下面这样子：   顶点1 顶点2   x y z x y z bit 4 8 12 16 20 24 位置数据被储存为32位（4字节）浮点值。 每个位置包含3个这样的值。 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。 数据中第一个值在缓冲开始的位置。 有了这些信息我们就可以使用glVertexAttribPointer()函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了： glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们： 第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。 下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子。 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。 现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用glEnableVertexAttribArray()，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样： // 0. 复制顶点数组到缓冲中供OpenGL使用 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 1. 设置顶点属性指针 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 2. 当我们渲染一个物体时要使用着色器程序 glUseProgram(shaderProgram); // 3. 绘制物体 someOpenGLFunctionThatDrawsOurTriangle(); 每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？ 七、顶点数组对象 顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 创建一个VAO和创建一个VBO很类似： unsigned int VAO; glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样： // ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: .. // 1. 绑定VAO glBindVertexArray(VAO); // 2. 把顶点数组复制到缓冲中供OpenGL使用 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 3. 设置顶点属性指针 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); [...] // ..:: 绘制代码（渲染循环中） :: .. // 4. 绘制物体 glUseProgram(shaderProgram); glBindVertexArray(VAO); someOpenGLFunctionThatDrawsOurTriangle(); 就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针），然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。 八、我们一直期待的三角形 要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。 glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。 现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果： 完整的程序源码可以在这里找到。 如果你的输出和这个看起来不一样，你可能做错了什么。去查看一下源码，检查你是否遗漏了什么东西，或者你也可以在评论区提问。 九、元素缓冲对象 在渲染顶点这一话题上我们还有最后一个需要讨论的东西——元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。要解释元素缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合： float vertices[] = { // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角 }; 可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？ 值得庆幸的是，元素缓冲区对象的工作方式正是如此。 EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。这种所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引： float vertices[] = { 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角 }; unsigned int indices[] = { // 注意索引从0开始! // 此例的索引(0,1,2,3)就是顶点数组vertices的下标， // 这样可以由下标代表顶点组合成矩形 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形 }; 你可以看到，当使用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建元素缓冲对象： unsigned int EBO; glGenBuffers(1, &amp;EBO); 与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 注意：我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，表示我们要从索引缓冲区渲染三角形。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制： glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。 glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取其索引。这意味着我们每次想要使用索引渲染对象时都必须绑定相应的EBO，这又有点麻烦。碰巧顶点数组对象也跟踪元素缓冲区对象绑定。在绑定VAO时，绑定的最后一个元素缓冲区对象存储为VAO的元素缓冲区对象。然后，绑定到VAO也会自动绑定该EBO。 最后的初始化和绘制代码现在看起来像这样： // ..:: 初始化代码 :: .. // 1. 绑定顶点数组对象 glBindVertexArray(VAO); // 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // 4. 设定顶点属性指针 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); [...] // ..:: 绘制代码（渲染循环中） :: .. glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0); 运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。 线框模式(Wireframe Mode) 要想用线框模式绘制你的三角形，你可以通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。 如果你像我这样成功绘制出了这个三角形或矩形，那么恭喜你，你成功地通过了现代OpenGL最难部分之一：绘制你自己的第一个三角形。这部分很难，因为在可以绘制第一个三角形之前你需要了解很多知识。幸运的是我们现在已经越过了这个障碍，接下来的教程会比较容易理解一些。]]></summary></entry><entry><title type="html">360卸载教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360.html" rel="alternate" type="text/html" title="360卸载教程" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360.html"><![CDATA[<p><strong>这份教程适用于大部分难以删除的软件，可以进行拓展</strong></p>

<p><del>话说回来，为什么大部分人都能随便下载到360啊</del></p>

<h2 id="第零部分目录查找">第零部分：目录查找</h2>

<p>按下 <code class="language-plaintext highlighter-rouge">Ctrl + Shift + Esc</code> ，打开控制面板，在左侧 <code class="language-plaintext highlighter-rouge">启动</code> 找到要删除的软件，右键，选择 <code class="language-plaintext highlighter-rouge">打开文件所在的位置(O)</code>，记此目录为 <code class="language-plaintext highlighter-rouge">PATH_RJ</code></p>

<h2 id="第一部分控制面板">第一部分：控制面板</h2>

<ol>
  <li>
    <p>打开 <code class="language-plaintext highlighter-rouge">控制面板</code> （方式有两种，<code class="language-plaintext highlighter-rouge">Win + r</code> 输入 <code class="language-plaintext highlighter-rouge">control</code> 或者修改桌面图标），找到 <code class="language-plaintext highlighter-rouge">程序与功能</code>，进去。</p>
  </li>
  <li>
    <p>你会看到一个列表，找到你要删除的软件，然后点击工具栏的 <code class="language-plaintext highlighter-rouge">卸载</code> （或者 <code class="language-plaintext highlighter-rouge">卸载/修改</code> ），然后，按照引导删除（注意文字）</p>
  </li>
</ol>

<h2 id="第二部分安全模式">第二部分：安全模式</h2>

<ol>
  <li>
    <p>关闭电脑，等待5秒后，开机狂按 <code class="language-plaintext highlighter-rouge">F8</code> （不是长按），进入 <code class="language-plaintext highlighter-rouge">疑难解答</code> ，进入 <code class="language-plaintext highlighter-rouge">高级选项</code> ，进入 <code class="language-plaintext highlighter-rouge">启动设置</code>，然后找到一行叫 <code class="language-plaintext highlighter-rouge">启用安全模式</code> 记住前面的数字，然后点击按钮重启</p>
  </li>
  <li>
    <p>重启时，按住你刚才记住的数字（如果你记住的是几，就按 <code class="language-plaintext highlighter-rouge">F几</code> ），然后进入系统。</p>
  </li>
  <li>
    <p>打开 <code class="language-plaintext highlighter-rouge">Windows 文件资源管理器</code> ，进入 <code class="language-plaintext highlighter-rouge">PATH_RJ</code> 的上一级目录，按住 <code class="language-plaintext highlighter-rouge">Shift + Delete</code> 彻底删除，然后重启</p>
  </li>
</ol>

<h2 id="第三部分删除注册表新手到上一步就可以了">第三部分：删除注册表（新手到上一步就可以了）</h2>

<p><code class="language-plaintext highlighter-rouge">Win + R</code> 输入 <code class="language-plaintext highlighter-rouge">regedit</code>，进入 <code class="language-plaintext highlighter-rouge">计算机\HKEY_LOCAL_MACHINE\SOFTWARE</code> 中，直接 <code class="language-plaintext highlighter-rouge">delete</code> 删除你不需要的软件目录</p>

<p><del>其实，这么删除仍然有残留，只是安全稳定</del></p>]]></content><author><name>agppd</name></author><category term="技术" /><summary type="html"><![CDATA[这份教程适用于大部分难以删除的软件，可以进行拓展]]></summary></entry><entry><title type="html">Nim（公平组合游戏）学习笔记</title><link href="http://localhost:4000/%E7%90%86%E8%AE%BA/%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88%E8%AE%BA/2026/02/26/Nim.html" rel="alternate" type="text/html" title="Nim（公平组合游戏）学习笔记" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E7%90%86%E8%AE%BA/%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88%E8%AE%BA/2026/02/26/Nim</id><content type="html" xml:base="http://localhost:4000/%E7%90%86%E8%AE%BA/%E6%95%B0%E5%AD%A6/%E5%8D%9A%E5%BC%88%E8%AE%BA/2026/02/26/Nim.html"><![CDATA[<p>下午<a href="https://www.luogu.com.cn/problem/P5675">刷题</a>碰到了，发现没学过，就学一下</p>

<p><strong>注：本学习笔记部分借助AI补充完成</strong></p>

<h2 id="背景">背景</h2>

<p>有 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个石子，有2个人，轮替每轮取走石子，每次可以取任意一堆的任意正整数数量的石子，谁最后能取走最后一个石子，谁获胜</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>容易验证，Nim 游戏是正常规则的公平组合游戏．

举个例子。当前，有3堆石子，石子的数量分别为2,5,4。那么，可以取走第1堆中的2个物品，局面就变成了0,5,4；也可以取走第2堆的4个物品，局面就变成了2,1,4。如果某一时刻的局面变为了0,0,5，甲取走了第3堆的5个物品，也就是取走了最后一个物品，此时甲获胜。
</code></pre></div></div>

<p>——摘自 <a href="https://oi-wiki.org/math/game-theory/impartial-game/#nim-%E6%B8%B8%E6%88%8F">OI-WIKI</a></p>

<h2 id="博弈图">博弈图</h2>

<p>我们显然可以列举出所有的状态，把各个状态绘制成有向图（方向指向影响的状态）</p>

<p>如以下两堆石子，第一堆一个，第二堆两个的图：</p>

<p><img src="/assets/image/nim.png" alt="Nim" /></p>

<p>显然，这有性质</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在正常规则的公平组合游戏中，

1. 没有后继状态的状态是必败状态 $\mathcal{P}$，

2. 一个状态是必胜状态 $\mathcal{N}$ 当且仅当存在至少一个它的后继状态为必败状态 $\mathcal{P}$，

3. 一个状态是必败状态 $\mathcal{P}$ 当且仅当它的所有后继状态均为必胜状态 $\mathcal{N}$。
</code></pre></div></div>

<p>——摘自 <a href="https://oi-wiki.org/math/game-theory/impartial-game/#nim-%E6%B8%B8%E6%88%8F">OI-WIKI</a></p>

<p>所以所有状态必为必胜或必败状态</p>

<h2 id="nim-和">Nim 和</h2>

<h3 id="前言">前言</h3>

<p>直接枚举所有状态显然不现实，我们需要一个简洁的判定方法。定义 <strong>Nim 和</strong> 为所有堆石子数的异或（XOR）值：</p>

\[S = a_1 \oplus a_2 \oplus \dots \oplus a_n\]

<h3 id="定理">定理</h3>

<p>在 Nim 游戏中，一个局面是必败态（即当前玩家无论如何操作都会输，假设对手完美发挥）当且仅当 Nim 和为 $0$。否则为必胜态。</p>

<p>翻译成人话就是</p>

<p>前$N$个状态若想必败，则</p>

\[a_1 \oplus a_2 \oplus \dots \oplus a_n = 0\]

<h3 id="证明by-deepseek">证明（By Deepseek）</h3>

<p>我们只需验证三条性质：</p>
<ol>
  <li>所有石子都被取完（即全 $0$ 局面）的 Nim 和为 $0$，且该局面为必败（因为没有石子可取）。</li>
  <li>若当前 Nim 和 $S \neq 0$，则存在一种取法，使得取后 Nim 和变为 $0$。构造：设 $S$ 的最高位为 $k$，则至少有一堆 $a_i$ 的二进制在该位为 $1$。从该堆中取走 $a_i - (a_i \oplus S)$ 个石子（可以验证该数大于 $0$），新堆变为 $a_i \oplus S$，此时整体异或变为 $0$。</li>
  <li>若当前 Nim 和 $S = 0$，则无论怎么取，取后 Nim 和一定非 $0$。因为改变任意一堆 $a_i$ 都会破坏异或为零的平衡。</li>
</ol>

<p>根据博弈论的基本结论，这样的局面划分正好对应必胜态与必败态。</p>

<p>例如，三堆 $(2,5,4)$，$2 \oplus 5 \oplus 4 = (010)_2 \oplus (101)_2 \oplus (100)_2 = (011)_2 = 3 \neq 0$，所以先手必胜。事实上，我们可以按上述构造法找到一步必胜操作。</p>

<h2 id="spraguegrundy-定理">Sprague–Grundy 定理</h2>

<h3 id="定义">定义</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Nim 游戏是公平组合游戏的“原型”。更一般地，对于任意一个公平组合游戏，我们可以将其分解为若干个独立子游戏的“和”，而整个游戏的胜负由各子游戏的 SG 值（Sprague–Grundy 值）的异或决定。SG 值定义为当前状态所有可能到达的状态的 SG 值集合的 mex（最小非负整数不在集合中）。
</code></pre></div></div>
<p>——来源于Deepseek生成</p>

<h3 id="spraguegrundy-理论">Sprague–Grundy 理论</h3>

<p><strong>所有公平组合游戏都等价于单堆 Nim 游戏</strong></p>

<h3 id="推论">推论</h3>

<p>见<a href="https://oi-wiki.org/math/game-theory/impartial-game/#spraguegrundy-%E5%87%BD%E6%95%B0">OI-WIKI</a></p>

<h2 id="例题">例题</h2>

<h3 id="luogu-p2197">luogu P2197</h3>

<p><a href="https://www.luogu.com.cn/problem/P2197">原题链接</a></p>

<p>纯板子，没啥可讲的，看代码吧（这代码再不会，回卢重早吧）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">T</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
            <span class="n">ans</span><span class="o">^=</span><span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">ans</span><span class="o">?</span><span class="s">"Yes</span><span class="se">\n</span><span class="s">"</span><span class="o">:</span><span class="s">"No</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="然后就是我的题了-luogu-p5675">然后就是我的题了 luogu P5675</h3>

<p><a href="https://www.luogu.com.cn/problem/P5675">原题链接</a></p>

<p>现在看起来，这题顺眼多了 <del>（其实就是数据范围小）</del></p>

<p>考虑暴力枚举 <code class="language-plaintext highlighter-rouge">Alice</code> 选的哪一堆石子，然后先计算异或和是否为0，但是，题目中又规定，让我必胜，所以还要让 <code class="language-plaintext highlighter-rouge">Alice</code> 无法在这一堆中选择足够的石子使得剩下的异或为0，所以给定 Alice 选择的这堆石子的数量一定需要小于等于其他选择的堆的数量的异或值。</p>

<p>然后设 $dp_{ij}$ 表示前 $i$ 堆中任意选择一些使得异或值为 $j$ 的方案数，然后暴力计算就行了</p>

<p>时间复杂度：
\(O( n^2 \times C )\)</p>

<p>其中 $C$ 是 $j$ 循环的值域</p>

<p>注意到：$j$ 这第二维是需要循环到值域的，然后我们看一眼每堆石子数量，发现 $C \leq 200$ ，验证一下，能过</p>

<p>然后你就会写出如下的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span><span class="o">=</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mf">2e2</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">));</span> <span class="c1">//记得清空</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">201</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="o">^</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span><span class="o">%</span><span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">201</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="o">=</span><span class="p">(</span><span class="n">ans</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ans</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>发现获得了 40pts 的高分</p>

<p><del>然后翻了一下题解</del></p>

<p>发现这篇<a href="https://www.luogu.com.cn/article/aux9zbpe">文章</a>的第二维 $j$ 循环范围为 $[0,256]$ ，而不是我们使用的 $200$ ，不知道为什么，反正改了就过了</p>

<p>AC CODE:（注意第一个版本的数组会越界）</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span><span class="o">=</span><span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mf">2e2</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="o">+</span><span class="mi">50</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">));</span> <span class="c1">//记得清空</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">256</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="o">^</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span><span class="o">%</span><span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">256</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">ans</span><span class="o">=</span><span class="p">(</span><span class="n">ans</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="n">mod</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ans</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><em>参考资料：OI-Wiki，具体数学</em></p>

<p><del>我才不会说这东西我整了一下午</del></p>]]></content><author><name>agppd</name></author><category term="理论" /><category term="数学" /><category term="博弈论" /><summary type="html"><![CDATA[下午刷题碰到了，发现没学过，就学一下]]></summary></entry><entry><title type="html">OpenGL系列转载教程一</title><link href="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL.html" rel="alternate" type="text/html" title="OpenGL系列转载教程一" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL</id><content type="html" xml:base="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL.html"><![CDATA[<h3 id="声明">声明</h3>

<p>本系列教程均属于转载教程，经作者的整理与重新编写，如有侵权，请联系作者删除。
本篇转载自https://learnopengl-cn.github.io/</p>

<h2 id="一下载及配置">一、下载及配置</h2>

<p>本教程基于 <code class="language-plaintext highlighter-rouge">c++</code>，建议使用Visual Studio进行编写，本教程以Visual Studio 2022为例。</p>

<h3 id="1下载">1.下载</h3>

<p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。</p>

<p><a href="http://www.glfw.org/download.html">下载页</a></p>

<p>下载后，我们需要编译生成的库和 <code class="language-plaintext highlighter-rouge">include</code>文件夹，使用CMake编译后获得<code class="language-plaintext highlighter-rouge">glfw3.lib</code>。</p>

<p>你可以直接把他放入编译器的<code class="language-plaintext highlighter-rouge">lib</code>目录下，或放在新目录下并链接。</p>

<p>在Windows下OpenGL本体已经内置，在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，这部分因平台而异。</p>

<p>OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。</p>

<p>我们需要GLAD来帮我们解决这个问题。</p>

<p>打开GLAD的<a href="http://glad.dav1d.de/">在线服务</a>，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能用）。之后将模式(Profile)设置为Core，并且保证选中了生成加载器(Generate a loader)选项。现在可以先（暂时）忽略扩展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。</p>

<p>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的Include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。</p>

<p>运行这份代码(下一节我们要学的)，如果出现一个墨绿色(RGB 0.2 0.3 0.3)的窗口，证明你配置正确。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SCR_WIDTH</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SCR_HEIGHT</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">glfwInit</span><span class="p">();</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>

<span class="cp">#ifdef __APPLE__
</span>    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_FORWARD_COMPAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
<span class="cp">#endif
</span>
    <span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="s">"LearnOpenGL"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">glfwTerminate</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span><span class="n">glfwGetProcAddress</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLAD"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>    

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_ESCAPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
        <span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>fbf</name></author><category term="OpenGL系列" /><summary type="html"><![CDATA[声明]]></summary></entry><entry><title type="html">OpenGL系列转载教程二</title><link href="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OpenGL2.html" rel="alternate" type="text/html" title="OpenGL系列转载教程二" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OpenGL2</id><content type="html" xml:base="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OpenGL2.html"><![CDATA[<h3 id="声明">声明</h3>

<p>本系列教程均属于转载教程，经作者的整理与重新编写，如有侵权，请联系作者删除。
本篇转载自https://learnopengl-cn.github.io/</p>

<h2 id="一准备好">一、准备好</h2>
<p>在这篇教程中，我们会教你如何成功创建一个窗口。</p>

<p>在你的主函数中写上这段代码，用于实例化GLFW窗口。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">glfwInit</span><span class="p">();</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>
    <span class="c1">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>首先<code class="language-plaintext highlighter-rouge">glfwInit()</code>用来初始化GLFW。
然后我们可以通过<code class="language-plaintext highlighter-rouge">glfwWindowHint()</code>来配置GLFW。
第一个参数来选择配置项，第二个是将配置项设置的值。配置项的所有选项都可以在 <a href="https://www.glfw.org/docs/latest/window.html#window_hints">GLFW’s window handling</a> 找到。</p>

<p>由于本教程都是基于OpenGL 3.3版本展开讨论的，所以我们需要告诉GLFW我们要使用的OpenGL版本是3.3，这样GLFW会在创建OpenGL上下文时做出适当的调整。这也可以确保用户在没有适当的OpenGL版本支持的情况下无法运行。</p>

<p>我们同样明确告诉GLFW我们使用的是核心模式(Core-profile)。明确告诉GLFW我们需要使用核心模式意味着我们只能使用OpenGL功能的一个子集（没有我们已不再需要的向后兼容特性）。如果使用的是Mac OS X系统，你还需要加下面这行代码到你的初始化代码中这些配置才能起作用（将上面的代码解除注释）</p>

<p>接下来我们创建一个窗口对象：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">"LearnOpenGL"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">glfwCreateWindow()</code>函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称，最后两个参数我们暂时忽略。</p>

<p>这个函数将会返回一个<code class="language-plaintext highlighter-rouge">GLFWwindow</code>对象，我们会在其它的GLFW操作中使用到。创建完窗口我们就可以通知GLFW将我们窗口的上下文设置为当前线程的主上下文了。</p>

<p>在之前的教程中已经提到过，GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span><span class="n">glfwGetProcAddress</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLAD"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</p>

<h2 id="二视口">二、视口</h2>

<p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉OpenGL渲染窗口的尺寸大小，即视口(Viewport)，这样OpenGL才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用glViewport函数来设置视口的尺寸：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
</code></pre></div></div>
<p>我们实际上也可以将视口的维度设置为比GLFW的维度小，这样子之后所有的OpenGL渲染将会在一个更小的窗口中显示，这样子的话我们也可以将一些其它元素显示在OpenGL视口之外。</p>

<p>然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div></div>
<p>这个帧缓冲大小函数需要一个GLFWwindow作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。</p>

<p>里面暂时只需要写上一行<code class="language-plaintext highlighter-rouge">glViewport</code>来根据传参改变视口尺寸就行。</p>

<p>我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>
</code></pre></div></div>
<p>我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。</p>

<h2 id="三渲染循环">三、渲染循环</h2>

<p>我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。我们希望程序在我们主动关闭它之前不断绘制图像并能够接受用户输入。因此，我们需要在程序中添加一个while循环，我们可以把它称之为渲染循环(Render Loop)，它能在我们让GLFW退出前一直保持运行。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="n">glfwPollEvents</span><span class="p">();</span>    
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">glfwWindowShouldClose()</code>检测是否被要求退出，<code class="language-plaintext highlighter-rouge">glfwPollEvents()</code>用于检测用户输入调用对应的回调函数，<code class="language-plaintext highlighter-rouge">glfwSwapBuffers()</code>会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</p>

<h4 id="双缓冲">双缓冲</h4>
<p>你可能已经在之前听说过它，可能是在使用其他图形库，或是制作CUI小游戏是，它可以消除屏幕闪烁。
应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>

<h2 id="四结束">四、结束？</h2>

<p>当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源。我们可以在main函数的最后调用<code class="language-plaintext highlighter-rouge">glfwTerminate()</code>完成。
在你可以尝试编译并运行你的应用程序了.如果你看见了一个非常无聊的黑色窗口，那么就对了！</p>

<h2 id="五交互">五、交互</h2>

<p>我们同样也希望能够在GLFW中实现一些输入控制，这可以通过使用GLFW的几个输入函数来完成。我们将会使用GLFW的<code class="language-plaintext highlighter-rouge">glfwGetKey()</code>，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个<code class="language-plaintext highlighter-rouge">processInput()</code>函数来让所有的输入代码保持整洁。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_ESCAPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
        <span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这会在按下ESC键时退出程序，是的，仅仅一个黑窗口，又能做什么交互呢？</p>

<p>我们接下来在渲染循环的每一个迭代中调用<code class="language-plaintext highlighter-rouge">processInput()</code>,这就给我们一个非常简单的方式来检测特定的键是否被按下，并在每一帧做出处理。</p>

<h2 id="六渲染">六、渲染</h2>

<p>我们要把所有的渲染(Rendering)操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。</p>

<p>为了测试一切都正常工作，我们使用一个自定义的颜色清空屏幕。在每个新的渲染迭代开始的时候我们总是希望清屏，否则我们仍能看见上一次迭代的渲染结果（这可能是你想要的效果，但通常这不是）。我们可以通过调用<code class="language-plaintext highlighter-rouge">glClear()</code>函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有<code class="language-plaintext highlighter-rouge">GL_COLOR_BUFFER_BIT</code>，<code class="language-plaintext highlighter-rouge">GL_DEPTH_BUFFER_BIT</code>和<code class="language-plaintext highlighter-rouge">GL_STENCIL_BUFFER_BIT</code>。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.3f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
</code></pre></div></div>
<p>在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p>

<p>如果你没得到正确的结果，或者你不知道怎么把所有东西放到一起，请参考上一期结尾的代码。</p>]]></content><author><name>fbf</name></author><category term="OpenGL系列" /><summary type="html"><![CDATA[声明]]></summary></entry><entry><title type="html">冷知识合集</title><link href="http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold.html" rel="alternate" type="text/html" title="冷知识合集" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold</id><content type="html" xml:base="http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold.html"><![CDATA[<p>一份冷知识合集，不定时更新（不强调哪种语言，默认 <code class="language-plaintext highlighter-rouge">C/C++</code>）</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">C/C++</code> 编译不生成 <code class="language-plaintext highlighter-rouge">.exe</code> 文件，只生成 <code class="language-plaintext highlighter-rouge">.o</code> 文件，连接后才可形成</li>
  <li><code class="language-plaintext highlighter-rouge">if</code> 与 <code class="language-plaintext highlighter-rouge">else</code> 是连一起的，所以你可以这么写
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">()</span>
 <span class="k">if</span><span class="p">(){}</span>
 <span class="k">else</span><span class="p">(){}</span>
</code></pre></div>    </div>
    <p>等价于</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">()</span>
<span class="p">{</span>
 <span class="k">if</span><span class="p">(){}</span>
 <span class="k">else</span><span class="p">(){}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>关流同步的时候，应该写
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">map&lt;template,template&gt; = set&lt;pair&lt;template,template&gt;&gt;</code></p>
  </li>
  <li>其实，使用 <code class="language-plaintext highlighter-rouge">goto</code> 与 <code class="language-plaintext highlighter-rouge">if</code> ，就可以实现循环
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">l1:</span>
<span class="err">语句</span>
<span class="k">if</span><span class="p">(</span><span class="err">条件</span><span class="p">)</span>
 <span class="k">goto</span> <span class="n">l1</span><span class="p">;</span>
<span class="err">剩余代码</span>
</code></pre></div>    </div>
    <p>等价于</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="err">条件</span><span class="p">)</span>
<span class="p">{</span>
 <span class="err">语句</span>
<span class="p">}</span>
<span class="err">剩余代码</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>agppd</name></author><category term="杂谈" /><category term="技术" /><summary type="html"><![CDATA[一份冷知识合集，不定时更新（不强调哪种语言，默认 C/C++）]]></summary></entry><entry><title type="html">C++模板分享——高精度</title><link href="http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/26/gaojing.html" rel="alternate" type="text/html" title="C++模板分享——高精度" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/26/gaojing</id><content type="html" xml:base="http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/26/gaojing.html"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">gaojing</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">BigInt</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">digits</span><span class="p">;</span>  <span class="c1">// ´æ´¢Êý×Ö£¨ÄæÐò£º¸öÎ»ÔÚdigits[0]£©</span>
    <span class="kt">bool</span> <span class="n">isNegative</span><span class="p">;</span>          <span class="c1">// ·ûºÅ±ê¼Ç</span>

    <span class="c1">// ÒÆ³ýÇ°µ¼Áã²¢´¦Àí½á¹ûÎª0µÄÇé¿ö</span>
    <span class="kt">void</span> <span class="n">removeLeadingZeros</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">digits</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digits</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// -0 ÊÓÎª 0</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ±È½Ï¾ø¶ÔÖµ´óÐ¡£¨ºöÂÔ·ûºÅ£©</span>
    <span class="kt">int</span> <span class="nf">compareAbs</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ¹¹Ôìº¯Êý</span>
    <span class="n">BigInt</span><span class="p">()</span> <span class="o">:</span> <span class="n">digits</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">isNegative</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="c1">// ´Ó×Ö·û´®¹¹Ôì</span>
    <span class="n">BigInt</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">digits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// ´Ó×Ö·û´®Ä©Î²¿ªÊ¼½âÎö£¨¸öÎ»¿ªÊ¼£©</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"Invalid character in number"</span><span class="p">);</span>
            <span class="n">digits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">removeLeadingZeros</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// ´ÓÕûÐÍ¹¹Ôì</span>
    <span class="n">BigInt</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">isNegative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">digits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ×ª»»Îª×Ö·û´®</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isNegative</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="sc">'-'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">digits</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">str</span> <span class="o">+=</span> <span class="kt">char</span><span class="p">(</span><span class="sc">'0'</span> <span class="o">+</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ×ª»»ÎªÕûÐÍ£¨¿ÉÄÜ¶ªÊ§¾«¶È»òÒç³ö£©</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">toLongLong</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ¼ì²éÒç³ö</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">19</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ³¬¹ýLLONG_MAXµÄÎ»Êý</span>
                <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">overflow_error</span><span class="p">(</span><span class="s">"BigInt too large for long long"</span><span class="p">);</span>
            <span class="p">}</span>
            
            <span class="n">num</span> <span class="o">+=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">power</span><span class="p">;</span>
            
            <span class="c1">// ¼ì²éÖÐ¼ä½á¹ûÒç³ö</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">LLONG_MAX</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">overflow_error</span><span class="p">(</span><span class="s">"BigInt too large for long long"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
            <span class="n">power</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">isNegative</span> <span class="o">?</span> <span class="o">-</span><span class="n">num</span> <span class="o">:</span> <span class="n">num</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ¼Ó·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isNegative</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">isNegative</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">BigInt</span> <span class="n">result</span><span class="p">;</span>
            <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="n">isNegative</span><span class="p">;</span>
            <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">?</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
                <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">result</span><span class="p">.</span><span class="n">removeLeadingZeros</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isNegative</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="p">(</span><span class="o">-*</span><span class="k">this</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ÓëÕûÐÍ¼Ó·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">+</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ÕûÐÍ¼Ó·¨£¨È«¾Öº¯Êý£©</span>
    <span class="k">friend</span> <span class="n">BigInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ¼õ·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isNegative</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">isNegative</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">BigInt</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">BigInt</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">compareAbs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
            <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="o">!</span><span class="n">isNegative</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="n">isNegative</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">borrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">?</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span> <span class="o">-</span> <span class="n">borrow</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">diff</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
                <span class="n">borrow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">borrow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="p">.</span><span class="n">removeLeadingZeros</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ÓëÕûÐÍ¼õ·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">-</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ÕûÐÍ¼õ·¨£¨È«¾Öº¯Êý£©</span>
    <span class="k">friend</span> <span class="n">BigInt</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ³Ë·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">BigInt</span> <span class="n">result</span><span class="p">;</span>
        <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="n">isNegative</span> <span class="o">^</span> <span class="n">other</span><span class="p">.</span><span class="n">isNegative</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">carry</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">long</span> <span class="kt">long</span> <span class="n">product</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> 
                                   <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> 
                                   <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> 
                                   <span class="n">carry</span><span class="p">;</span>
                <span class="n">result</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">product</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="n">product</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="p">.</span><span class="n">removeLeadingZeros</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ÓëÕûÐÍ³Ë·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">*</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ÕûÐÍ³Ë·¨£¨È«¾Öº¯Êý£©</span>
    <span class="k">friend</span> <span class="n">BigInt</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ³ý·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">divisor</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">==</span> <span class="n">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Division by zero"</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">BigInt</span> <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span><span class="p">;</span>
        <span class="n">quotient</span><span class="p">.</span><span class="n">digits</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">quotient</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="n">isNegative</span> <span class="o">^</span> <span class="n">divisor</span><span class="p">.</span><span class="n">isNegative</span><span class="p">;</span>
        
        <span class="n">BigInt</span> <span class="n">absDivisor</span> <span class="o">=</span> <span class="n">divisor</span><span class="p">.</span><span class="n">abs</span><span class="p">();</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">*</span> <span class="n">BigInt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">&gt;=</span> <span class="n">absDivisor</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">remainder</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">-</span> <span class="n">absDivisor</span><span class="p">;</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">quotient</span><span class="p">.</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">quotient</span><span class="p">.</span><span class="n">removeLeadingZeros</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">quotient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ÓëÕûÐÍ³ý·¨</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">/</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ÕûÐÍ³ý·¨£¨È«¾Öº¯Êý£©</span>
    <span class="k">friend</span> <span class="n">BigInt</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">/</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// È¡¸º</span>
    <span class="n">BigInt</span> <span class="k">operator</span><span class="o">-</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">BigInt</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="o">!</span><span class="n">isNegative</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ¾ø¶ÔÖµ</span>
    <span class="n">BigInt</span> <span class="n">abs</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">BigInt</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">result</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ±È½ÏÔËËã·û</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isNegative</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">isNegative</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">isNegative</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">compareAbs</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">isNegative</span> <span class="o">?</span> <span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span> <span class="o">&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">other</span> <span class="o">&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">isNegative</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">isNegative</span> <span class="o">&amp;&amp;</span> <span class="n">digits</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">digits</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="p">);</span> <span class="p">}</span>

    <span class="c1">// ÓëÕûÐÍ±È½Ï</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">&lt;=</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">&gt;=</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span> <span class="o">!=</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span>

    <span class="c1">// ÕûÐÍ±È½Ï£¨È«¾Öº¯Êý£©</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">BigInt</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Êä³öÔËËã·û</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">BigInt</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace gaojing</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">gaojing</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name>agppd</name></author><category term="模板" /><summary type="html"><![CDATA[```cpp #include #include #include #include #include #include #include using namespace std; namespace gaojing {]]></summary></entry><entry><title type="html">德·摩根定律</title><link href="http://localhost:4000/%E9%80%BB%E8%BE%91/%E6%95%B0%E5%AD%A6/%E7%90%86%E8%AE%BA/2026/02/26/mogen.html" rel="alternate" type="text/html" title="德·摩根定律" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E9%80%BB%E8%BE%91/%E6%95%B0%E5%AD%A6/%E7%90%86%E8%AE%BA/2026/02/26/mogen</id><content type="html" xml:base="http://localhost:4000/%E9%80%BB%E8%BE%91/%E6%95%B0%E5%AD%A6/%E7%90%86%E8%AE%BA/2026/02/26/mogen.html"><![CDATA[<p>德·摩根定律，逻辑学一条极其重要的化简定律</p>

<p><strong>除了特殊说明，符号均采用默认含义</strong></p>

<h2 id="公式">公式</h2>

<p><strong>逻辑形式：</strong></p>
<ul>
  <li>$\neg (A \land B) \equiv \neg A \lor \neg B$</li>
  <li>$\neg (A \lor B) \equiv \neg A \land \neg B$</li>
</ul>

<p><strong>集合形式：</strong></p>
<ul>
  <li>$(A \cap B)^c = A^c \cup B^c$</li>
  <li>$(A \cup B)^c = A^c \cap B^c$</li>
</ul>

<h2 id="推广">推广</h2>

<p>没什么可说的，就是无脑扩展</p>

<h2 id="应用">应用</h2>

<h3 id="一个非常重要的应用异或门">一个非常重要的应用——异或门</h3>

<p>首先，真值表如下</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">0</th>
      <th style="text-align: right">0</th>
      <th style="text-align: right">1</th>
      <th style="text-align: right">1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">0</td>
    </tr>
  </tbody>
</table>

<p>显然，逻辑函数如下</p>

\[F = A B^{\prime} + A^{\prime} B\]

<p>然后，绘制电路（使用国际通用逻辑门）</p>

<p><del>其实就是一个第二刻与第三刻或起开</del></p>

<p>懒得处理交点了，应该都能看懂吧</p>

<p><img src="/assets/image/men1.png" alt="异或门1" /></p>

<p>利用德·摩根定律可知，我们可以进行化简</p>

<p><img src="/assets/image/men2.png" alt="异或门2" /></p>

<p>这定律也就差不多讲完了</p>]]></content><author><name>agppd</name></author><category term="逻辑" /><category term="数学" /><category term="理论" /><summary type="html"><![CDATA[德·摩根定律，逻辑学一条极其重要的化简定律]]></summary></entry><entry><title type="html">C++模板分享——单向ADT链表</title><link href="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb.html" rel="alternate" type="text/html" title="C++模板分享——单向ADT链表" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb</id><content type="html" xml:base="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb.html"><![CDATA[<p>发现没有单向链表，只有双向（stl 的 <code class="language-plaintext highlighter-rouge">list</code>），我也写一个</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    Self made list, 
    Not for stl 
    
    这是一份线性表，但不符合stl的标准
*/</span>
<span class="cp">#ifndef XIANXINGBIAO_H
#define XIANXINGBIAO_H
</span>
<span class="cp">#define ADD_SIZE 10
#define LENGTH 128
</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">XIANXINGBIAO</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">list</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Node</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>   <span class="c1">// 存储用指针</span>
        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span><span class="c1">// 当前长度</span>
        <span class="kt">int</span> <span class="n">listsize</span><span class="p">;</span><span class="c1">// 当前分配的存储容量（以sizeof(T)为单位）</span>
    <span class="p">}</span> <span class="n">L</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* 构造函数：初始化线性表 */</span>
    <span class="n">list</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">ADD_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="n">ADD_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 析构函数：释放内存 */</span>
    <span class="o">~</span><span class="n">list</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:销毁线性表L。 */</span>
    <span class="kt">void</span> <span class="nf">del</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:将L置为空表。 */</span>
    <span class="kt">void</span> <span class="nf">clear</span><span class="p">(){</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:若L为空，则返回TRUE，否则返回FALSE。 */</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">(){</span><span class="k">return</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">);}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:返回L中数据元素个数。同length */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:返回L中数据元素个数。同size */</span>
    <span class="kt">int</span> <span class="nf">length</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果:返回L中第i个元素的值。 */</span>
    <span class="n">T</span> <span class="nf">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">id</span><span class="o">&gt;</span><span class="n">length</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">id</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果:用e返回L中第i个元素的值。 */</span>
    <span class="kt">bool</span> <span class="nf">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">id</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">id</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */</span>
    <span class="cm">/* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回0。 */</span>
    <span class="kt">int</span> <span class="nf">compare_find</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span><span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">e</span><span class="p">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */</span>
    <span class="cm">/* 操作结果：判断L中是否存在与e满足关系compare()的数据元素。若存在，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">compare_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span><span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">compare_find</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">compare</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回它的前驱，否则操作失败。 */</span>
    <span class="n">T</span> <span class="nf">pre_find</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"Not found!"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">pre_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回它的后继，否则操作失败。 */</span>
    <span class="n">T</span> <span class="nf">nxt_find</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span> <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"Not found!"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">nxt_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,1≤i≤ListLength(L)+1。 */</span>
    <span class="cm">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。 */</span>
    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">T</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;=</span><span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">T</span><span class="o">*</span> <span class="n">new_elem</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">,(</span><span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">+</span><span class="n">LENGTH</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">new_elem</span><span class="p">);</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="n">new_elem</span><span class="p">;</span>
            <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">+=</span><span class="n">LENGTH</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在且非空，1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果：删除L的第i个数据元素，L的长度减1。 */</span>
    <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">))</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 目的：遍历整个线性表L。 */</span>
    <span class="cm">/* 操作结果:依次对L的每个数据元素调用函数visit()。 */</span>
    <span class="kt">void</span> <span class="nf">bl</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">visit</span><span class="p">)(</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：返回线性表L的起始位置（索引0） */</span>
    <span class="kt">int</span> <span class="nf">begin</span><span class="p">(){</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：返回线性表L的结尾位置（索引length-1） */</span>
    <span class="kt">int</span> <span class="nf">end</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;}</span>

    <span class="cm">/* 初始条件：线性表长度已存在 */</span>
    <span class="cm">/* 操作结果：从输入读入，创建一个从0开始的新线性表,cin读入 */</span>
    <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：正序遍历线性表，以空格分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outF_</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：正序遍历线性表，以换行分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outFn</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：倒序遍历线性表，以空格分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outD_</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：倒序遍历线性表，以换行分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outDn</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace XIANXINGBIAO</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">XIANXINGBIAO</span><span class="p">;</span>

<span class="cp">#endif
</span></code></pre></div></div>]]></content><author><name>agppd</name></author><category term="数据结构" /><category term="模板" /><summary type="html"><![CDATA[发现没有单向链表，只有双向（stl 的 list），我也写一个]]></summary></entry><entry><title type="html">VScode配置教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting.html" rel="alternate" type="text/html" title="VScode配置教程" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting.html"><![CDATA[<p>大部分人入门一门语言大部分是通过IDE类的编译器入门的吧，显然，显示开发中，IDE的弊端明显（如：大部分IDE老旧，编译器更新困难），所以我们常使用文本编译器进行代码的编写，本文档主要讨论VScode的配置</p>

<h2 id="准备工作">准备工作</h2>

<p>在<a href="https://code.visualstudio.com/Download">VScode官网</a>进行下载VScode，下载完成后进行解压安装</p>

<h2 id="获取c编译器如果你已经拥有直接跳过记c编译器路径为-c_path-">获取C++编译器（如果你已经拥有，直接跳过，记C++编译器路径为 C_PATH ）</h2>

<h3 id="windows">Windows</h3>

<p>在<a href="https://www.msys2.org/">MSYS2官网</a>进行下载，有时，下载会很慢，所以我们常使用<a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/msys2-x86_64-latest.exe">清华源</a>进行下载</p>

<p>安装时，先断网，然后再开始下载</p>

<p>为了方便，我们后记安装路径为 <code class="language-plaintext highlighter-rouge">MSYS2_PATH</code></p>

<p>进入 <code class="language-plaintext highlighter-rouge">MAYS2_PATH</code> ，为了方便与统一，我们统一部署 <code class="language-plaintext highlighter-rouge">MINGW</code> ，双击 <code class="language-plaintext highlighter-rouge">MSYS MINGW64</code>，以后都在里面进行部署</p>

<p>先更新 <code class="language-plaintext highlighter-rouge">pacman</code> （ARCH系的包管理器）</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-Syu</span>
</code></pre></div></div>

<p>大部分情况下需要关闭后重新更新，接着输入如下内容</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-Su</span>
</code></pre></div></div>

<p>现在，就更新好了（类似于常见的 <code class="language-plaintext highlighter-rouge">apt audate</code> ）</p>

<p>为了后期部署项目方便，直接安装编译工具链</p>

<p><strong>64 位</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> mingw-w64-x86_64-toolchain
</code></pre></div></div>

<p><strong>32 位</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> mingw-w64-i686-toolchain
</code></pre></div></div>

<p>进入 <code class="language-plaintext highlighter-rouge">MAYS2_PATH</code> ，记里面的 <code class="language-plaintext highlighter-rouge">mingw32</code> 为 <code class="language-plaintext highlighter-rouge">C_PATH</code></p>

<p>将 <code class="language-plaintext highlighter-rouge">C_PATH\bin</code> 添加到环境变量</p>

<p>在<strong>管理员：命令提示符</strong>中输入</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setx /M PATH <span class="s2">"%PATH%;C_PATH</span><span class="se">\b</span><span class="s2">in"</span>
</code></pre></div></div>

<p>然后输入如下命令进行重启电脑</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown <span class="nt">-r</span> <span class="nt">-t</span> 0
</code></pre></div></div>

<hr />

<h3 id="linux">Linux</h3>

<p>这个还真是不太好整</p>

<p>就是各个系的Linux使用各自的包管理器安装编译工具链即可，然后什么都不用管了，记 <code class="language-plaintext highlighter-rouge">bin\gcc</code> 为 <code class="language-plaintext highlighter-rouge">C_PATH</code></p>

<hr />

<h3 id="官网下载">官网下载</h3>

<p><del>话说，我现在才说是不是有点坑人</del></p>

<h2 id="配置vscode">配置VScode</h2>

<h3 id="配置cc">配置C/C++</h3>

<p>按下 <code class="language-plaintext highlighter-rouge">Ctrl + Shift + X</code> ，打开拓展，搜索 <code class="language-plaintext highlighter-rouge">C/C++</code> ，然后下载官方的插件，然后写一个 <code class="language-plaintext highlighter-rouge">Hello World!</code> ，如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Hello World!"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果此时VScode右上角出现小箭头（运行），那么就让它自己配置，然后就可以使用了  <del>本文完</del></p>

<p>如果失败了，在项目文件夹根目录下新建一个叫 <code class="language-plaintext highlighter-rouge">.vscode</code> 的文件夹，创建一个叫 <code class="language-plaintext highlighter-rouge">tasks.json</code> 的文件，按照如下格式编写（我们使用 <code class="language-plaintext highlighter-rouge">G++</code> ，愿意使用 <code class="language-plaintext highlighter-rouge">GCC + 参数</code> 的自行修改）</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppbuild"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C/C++: g++.exe 生成活动文件"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C_PATH</span><span class="se">\\</span><span class="s2">g++.exe"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"-fdiagnostics-color=always"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"-g"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${file}"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"-o"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${fileDirname}</span><span class="se">\\</span><span class="s2">${fileBasenameNoExtension}.exe"</span><span class="w">
                </span><span class="err">//</span><span class="w"> </span><span class="err">其实就是编译参数，每个后面要有英文逗号</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${fileDirname}"</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"$gcc"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"调试器生成的任务。"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Q：这样的可以编译中文文件吗？</p>

<p>A：分情况，VScode不行，命令行行（使用MINGW）</p>

<p>比如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-o</span> run.exe 你好.cpp <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-std</span><span class="o">=</span>c++17
</code></pre></div></div>

<p>就行，<del>就是不知道终端里怎么输入中文</del></p>

<p><strong>如果，你使用的是你以前IDE的编译器，请自己在C/C++里添加头文件路径！！！否则VScode会无端报错</strong></p>

<h3 id="推荐插件">推荐插件</h3>

<p>其实，插件这个东西，应该自己玩，但是吧，我还是想说一下语言翻译插件</p>

<p>以中文为例：同 <code class="language-plaintext highlighter-rouge">C/C++</code> 插件的安装方式，搜 <code class="language-plaintext highlighter-rouge">Chinese</code> 然后下载</p>

<hr />

<p>到此为止，VScode最基础的内容介绍完毕</p>]]></content><author><name>agppd</name></author><category term="技术" /><summary type="html"><![CDATA[大部分人入门一门语言大部分是通过IDE类的编译器入门的吧，显然，显示开发中，IDE的弊端明显（如：大部分IDE老旧，编译器更新困难），所以我们常使用文本编译器进行代码的编写，本文档主要讨论VScode的配置]]></summary></entry></feed>