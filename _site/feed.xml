<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-02-26T09:51:30+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">agppd团队 的博客</title><subtitle>个人运营的团队技术博客</subtitle><entry><title type="html">360卸载教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360.html" rel="alternate" type="text/html" title="360卸载教程" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/26/360.html"><![CDATA[<p><strong>这份教程适用于大部分难以删除的软件，可以进行拓展</strong></p>

<p><del>话说回来，为什么大部分人都能随便下载到360啊</del></p>

<h2 id="第零部分目录查找">第零部分：目录查找</h2>

<p>按下 <code class="language-plaintext highlighter-rouge">Ctrl + Shift + Esc</code> ，打开控制面板，在左侧 <code class="language-plaintext highlighter-rouge">启动</code> 找到要删除的软件，右键，选择 <code class="language-plaintext highlighter-rouge">打开文件所在的位置(O)</code>，记此目录为 <code class="language-plaintext highlighter-rouge">PATH_RJ</code></p>

<h2 id="第一部分控制面板">第一部分：控制面板</h2>

<ol>
  <li>
    <p>打开 <code class="language-plaintext highlighter-rouge">控制面板</code> （方式有两种，<code class="language-plaintext highlighter-rouge">Win + r</code> 输入 <code class="language-plaintext highlighter-rouge">control</code> 或者修改桌面图标），找到 <code class="language-plaintext highlighter-rouge">程序与功能</code>，进去。</p>
  </li>
  <li>
    <p>你会看到一个列表，找到你要删除的软件，然后点击工具栏的 <code class="language-plaintext highlighter-rouge">卸载</code> （或者 <code class="language-plaintext highlighter-rouge">卸载/修改</code> ），然后，按照引导删除（注意文字）</p>
  </li>
</ol>

<h2 id="第二部分安全模式">第二部分：安全模式</h2>

<ol>
  <li>
    <p>关闭电脑，等待5秒后，开机狂按 <code class="language-plaintext highlighter-rouge">F8</code> （不是长按），进入 <code class="language-plaintext highlighter-rouge">疑难解答</code> ，进入 <code class="language-plaintext highlighter-rouge">高级选项</code> ，进入 <code class="language-plaintext highlighter-rouge">启动设置</code>，然后找到一行叫 <code class="language-plaintext highlighter-rouge">启用安全模式</code> 记住前面的数字，然后点击按钮重启</p>
  </li>
  <li>
    <p>重启时，按住你刚才记住的数字（如果你记住的是几，就按 <code class="language-plaintext highlighter-rouge">F几</code> ），然后进入系统。</p>
  </li>
  <li>
    <p>打开 <code class="language-plaintext highlighter-rouge">Windows 文件资源管理器</code> ，进入 <code class="language-plaintext highlighter-rouge">PATH_RJ</code> 的上一级目录，按住 <code class="language-plaintext highlighter-rouge">Shift + Delete</code> 彻底删除，然后重启</p>
  </li>
</ol>

<h2 id="第三部分删除注册表新手到上一步就可以了">第三部分：删除注册表（新手到上一步就可以了）</h2>

<p><code class="language-plaintext highlighter-rouge">Win + R</code> 输入 <code class="language-plaintext highlighter-rouge">regedit</code>，进入 <code class="language-plaintext highlighter-rouge">计算机\HKEY_LOCAL_MACHINE\SOFTWARE</code> 中，直接 <code class="language-plaintext highlighter-rouge">delete</code> 删除你不需要的软件目录</p>

<p><del>其实，这么删除仍然有残留，只是安全稳定</del></p>]]></content><author><name>agppd</name></author><category term="技术" /><summary type="html"><![CDATA[这份教程适用于大部分难以删除的软件，可以进行拓展]]></summary></entry><entry><title type="html">OpenGL系列转载教程一</title><link href="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL.html" rel="alternate" type="text/html" title="OpenGL系列转载教程一" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL</id><content type="html" xml:base="http://localhost:4000/opengl%E7%B3%BB%E5%88%97/2026/02/26/OPenGL.html"><![CDATA[<h3 id="声明">声明</h3>

<p>本系列教程均属于转载教程，经作者的整理与重新编写，如有侵权，请联系作者删除。
本篇转载自https://learnopengl-cn.github.io/</p>

<h2 id="一下载及配置">一、下载及配置</h2>

<p>本教程基于 <code class="language-plaintext highlighter-rouge">c++</code>，建议使用Visual Studio进行编写，本教程以Visual Studio 2022为例。</p>

<h3 id="1下载">1.下载</h3>

<p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。</p>

<p><a href="http://www.glfw.org/download.html">下载页</a></p>

<p>下载后，我们需要编译生成的库和 <code class="language-plaintext highlighter-rouge">include</code>文件夹，使用CMake编译后获得<code class="language-plaintext highlighter-rouge">glfw3.lib</code>。</p>

<p>你可以直接把他放入编译器的<code class="language-plaintext highlighter-rouge">lib</code>目录下，或放在新目录下并链接。</p>

<p>在Windows下OpenGL本体已经内置，在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，这部分因平台而异。</p>

<p>OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。</p>

<p>我们需要GLAD来帮我们解决这个问题。</p>

<p>打开GLAD的<a href="http://glad.dav1d.de/">在线服务</a>，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能用）。之后将模式(Profile)设置为Core，并且保证选中了生成加载器(Generate a loader)选项。现在可以先（暂时）忽略扩展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。</p>

<p>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的Include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。</p>

<p>运行这份代码(下一节我们要学的)，如果出现一个墨绿色(RGB 0.2 0.3 0.3)的窗口，证明你配置正确。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;glad/glad.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SCR_WIDTH</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">SCR_HEIGHT</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">glfwInit</span><span class="p">();</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span>

<span class="cp">#ifdef __APPLE__
</span>    <span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_FORWARD_COMPAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
<span class="cp">#endif
</span>
    <span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="n">SCR_WIDTH</span><span class="p">,</span> <span class="n">SCR_HEIGHT</span><span class="p">,</span> <span class="s">"LearnOpenGL"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">glfwTerminate</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="n">glfwSetFramebufferSizeCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">framebuffer_size_callback</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gladLoadGLLoader</span><span class="p">((</span><span class="n">GLADloadproc</span><span class="p">)</span><span class="n">glfwGetProcAddress</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLAD"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>    

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">processInput</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.3</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.3</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">processInput</span><span class="p">(</span><span class="n">GLFWwindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">GLFW_KEY_ESCAPE</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLFW_PRESS</span><span class="p">)</span>
        <span class="n">glfwSetWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">framebuffer_size_callback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>fbf</name></author><category term="OpenGL系列" /><summary type="html"><![CDATA[声明]]></summary></entry><entry><title type="html">冷知识合集</title><link href="http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold.html" rel="alternate" type="text/html" title="冷知识合集" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold</id><content type="html" xml:base="http://localhost:4000/%E6%9D%82%E8%B0%88/%E6%8A%80%E6%9C%AF/2026/02/26/cold.html"><![CDATA[<p>一份冷知识合集，不定时更新（不强调哪种语言，默认 <code class="language-plaintext highlighter-rouge">C/C++</code>）</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">C/C++</code> 编译不生成 <code class="language-plaintext highlighter-rouge">.exe</code> 文件，只生成 <code class="language-plaintext highlighter-rouge">.o</code> 文件，连接后才可形成</li>
  <li><code class="language-plaintext highlighter-rouge">if</code> 与 <code class="language-plaintext highlighter-rouge">else</code> 是连一起的，所以你可以这么写
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">()</span>
 <span class="k">if</span><span class="p">(){}</span>
 <span class="k">else</span><span class="p">(){}</span>
</code></pre></div>    </div>
    <p>等价于</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">()</span>
<span class="p">{</span>
 <span class="k">if</span><span class="p">(){}</span>
 <span class="k">else</span><span class="p">(){}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>关流同步的时候，应该写
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">map&lt;template,template&gt; = set&lt;pair&lt;template,template&gt;&gt;</code></p>
  </li>
  <li>其实，使用 <code class="language-plaintext highlighter-rouge">goto</code> 与 <code class="language-plaintext highlighter-rouge">if</code> ，就可以实现循环
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">l1:</span>
<span class="err">语句</span>
<span class="k">if</span><span class="p">(</span><span class="err">条件</span><span class="p">)</span>
 <span class="k">goto</span> <span class="n">l1</span><span class="p">;</span>
<span class="err">剩余代码</span>
</code></pre></div>    </div>
    <p>等价于</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="err">条件</span><span class="p">)</span>
<span class="p">{</span>
 <span class="err">语句</span>
<span class="p">}</span>
<span class="err">剩余代码</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name>agppd</name></author><category term="杂谈" /><category term="技术" /><summary type="html"><![CDATA[一份冷知识合集，不定时更新（不强调哪种语言，默认 C/C++）]]></summary></entry><entry><title type="html">C++模板分享——单向ADT链表</title><link href="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb.html" rel="alternate" type="text/html" title="C++模板分享——单向ADT链表" /><published>2026-02-26T00:00:00+08:00</published><updated>2026-02-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb</id><content type="html" xml:base="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/26/xxb.html"><![CDATA[<p>发现没有单向链表，只有双向（stl 的 <code class="language-plaintext highlighter-rouge">list</code>），我也写一个</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
    Self made list, 
    Not for stl 
    
    这是一份线性表，但不符合stl的标准
*/</span>
<span class="cp">#ifndef XIANXINGBIAO_H
#define XIANXINGBIAO_H
</span>
<span class="cp">#define ADD_SIZE 10
#define LENGTH 128
</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">XIANXINGBIAO</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">list</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Node</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>   <span class="c1">// 存储用指针</span>
        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span><span class="c1">// 当前长度</span>
        <span class="kt">int</span> <span class="n">listsize</span><span class="p">;</span><span class="c1">// 当前分配的存储容量（以sizeof(T)为单位）</span>
    <span class="p">}</span> <span class="n">L</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* 构造函数：初始化线性表 */</span>
    <span class="n">list</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">ADD_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="n">ADD_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 析构函数：释放内存 */</span>
    <span class="o">~</span><span class="n">list</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:销毁线性表L。 */</span>
    <span class="kt">void</span> <span class="nf">del</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">);</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:将L置为空表。 */</span>
    <span class="kt">void</span> <span class="nf">clear</span><span class="p">(){</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:若L为空，则返回TRUE，否则返回FALSE。 */</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">(){</span><span class="k">return</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">==</span><span class="mi">0</span><span class="p">);}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:返回L中数据元素个数。同length */</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在。 */</span>
    <span class="cm">/* 操作结果:返回L中数据元素个数。同size */</span>
    <span class="kt">int</span> <span class="nf">length</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;}</span>

    <span class="cm">/* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果:返回L中第i个元素的值。 */</span>
    <span class="n">T</span> <span class="nf">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">id</span><span class="o">&gt;</span><span class="n">length</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">id</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件:线性表L已存在,1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果:用e返回L中第i个元素的值。 */</span>
    <span class="kt">bool</span> <span class="nf">ask</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">id</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">id</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */</span>
    <span class="cm">/* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回0。 */</span>
    <span class="kt">int</span> <span class="nf">compare_find</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span><span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">e</span><span class="p">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,compare()是数据元素判断函数。 */</span>
    <span class="cm">/* 操作结果：判断L中是否存在与e满足关系compare()的数据元素。若存在，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">compare_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span><span class="kt">bool</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">(</span><span class="n">compare_find</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">compare</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回它的前驱，否则操作失败。 */</span>
    <span class="n">T</span> <span class="nf">pre_find</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"Not found!"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是第一个，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">pre_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回它的后继，否则操作失败。 */</span>
    <span class="n">T</span> <span class="nf">nxt_find</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span> <span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"Not found!"</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：若cur_e是L的数据元素，且不是最后一个，则返回true，否则返回false。 */</span>
    <span class="kt">bool</span> <span class="nf">nxt_pd</span><span class="p">(</span><span class="n">T</span> <span class="n">cur_e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">cur_e</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在,1≤i≤ListLength(L)+1。 */</span>
    <span class="cm">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。 */</span>
    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">T</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="n">or</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;=</span><span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">T</span><span class="o">*</span> <span class="n">new_elem</span><span class="o">=</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">,(</span><span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">+</span><span class="n">LENGTH</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">new_elem</span><span class="p">);</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="o">=</span><span class="n">new_elem</span><span class="p">;</span>
            <span class="n">L</span><span class="p">.</span><span class="n">listsize</span><span class="o">+=</span><span class="n">LENGTH</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在且非空，1≤i≤ListLength(L)。 */</span>
    <span class="cm">/* 操作结果：删除L的第i个数据元素，L的长度减1。 */</span>
    <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">))</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 目的：遍历整个线性表L。 */</span>
    <span class="cm">/* 操作结果:依次对L的每个数据元素调用函数visit()。 */</span>
    <span class="kt">void</span> <span class="nf">bl</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">visit</span><span class="p">)(</span><span class="n">T</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：返回线性表L的起始位置（索引0） */</span>
    <span class="kt">int</span> <span class="nf">begin</span><span class="p">(){</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>

    <span class="cm">/* 初始条件：线性表L已存在。 */</span>
    <span class="cm">/* 操作结果：返回线性表L的结尾位置（索引length-1） */</span>
    <span class="kt">int</span> <span class="nf">end</span><span class="p">(){</span><span class="k">return</span> <span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;}</span>

    <span class="cm">/* 初始条件：线性表长度已存在 */</span>
    <span class="cm">/* 操作结果：从输入读入，创建一个从0开始的新线性表,cin读入 */</span>
    <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：正序遍历线性表，以空格分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outF_</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：正序遍历线性表，以换行分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outFn</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：倒序遍历线性表，以空格分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outD_</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 初始条件：线性表已存在 */</span>
    <span class="cm">/* 操作结果：倒序遍历线性表，以换行分开，cout输出 */</span>
    <span class="kt">void</span> <span class="nf">outDn</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace XIANXINGBIAO</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">XIANXINGBIAO</span><span class="p">;</span>

<span class="cp">#endif
</span></code></pre></div></div>]]></content><author><name>agppd</name></author><category term="数据结构" /><category term="模板" /><summary type="html"><![CDATA[发现没有单向链表，只有双向（stl 的 list），我也写一个]]></summary></entry><entry><title type="html">VScode配置教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting.html" rel="alternate" type="text/html" title="VScode配置教程" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VScodesetting.html"><![CDATA[<p>大部分人入门一门语言大部分是通过IDE类的编译器入门的吧，显然，显示开发中，IDE的弊端明显（如：大部分IDE老旧，编译器更新困难），所以我们常使用文本编译器进行代码的编写，本文档主要讨论VScode的配置</p>

<h2 id="准备工作">准备工作</h2>

<p>在<a href="https://code.visualstudio.com/Download">VScode官网</a>进行下载VScode，下载完成后进行解压安装</p>

<h2 id="获取c编译器如果你已经拥有直接跳过记c编译器路径为-c_path-">获取C++编译器（如果你已经拥有，直接跳过，记C++编译器路径为 C_PATH ）</h2>

<h3 id="windows">Windows</h3>

<p>在<a href="https://www.msys2.org/">MSYS2官网</a>进行下载，有时，下载会很慢，所以我们常使用<a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/msys2-x86_64-latest.exe">清华源</a>进行下载</p>

<p>安装时，先断网，然后再开始下载</p>

<p>为了方便，我们后记安装路径为 <code class="language-plaintext highlighter-rouge">MSYS2_PATH</code></p>

<p>进入 <code class="language-plaintext highlighter-rouge">MAYS2_PATH</code> ，为了方便与统一，我们统一部署 <code class="language-plaintext highlighter-rouge">MINGW</code> ，双击 <code class="language-plaintext highlighter-rouge">MSYS MINGW64</code>，以后都在里面进行部署</p>

<p>先更新 <code class="language-plaintext highlighter-rouge">pacman</code> （ARCH系的包管理器）</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-Syu</span>
</code></pre></div></div>

<p>大部分情况下需要关闭后重新更新，接着输入如下内容</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-Su</span>
</code></pre></div></div>

<p>现在，就更新好了（类似于常见的 <code class="language-plaintext highlighter-rouge">apt audate</code> ）</p>

<p>为了后期部署项目方便，直接安装编译工具链</p>

<p><strong>64 位</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> mingw-w64-x86_64-toolchain
</code></pre></div></div>

<p><strong>32 位</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> mingw-w64-i686-toolchain
</code></pre></div></div>

<p>进入 <code class="language-plaintext highlighter-rouge">MAYS2_PATH</code> ，记里面的 <code class="language-plaintext highlighter-rouge">mingw32</code> 为 <code class="language-plaintext highlighter-rouge">C_PATH</code></p>

<p>将 <code class="language-plaintext highlighter-rouge">C_PATH\bin</code> 添加到环境变量</p>

<p>在<strong>管理员：命令提示符</strong>中输入</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setx /M PATH <span class="s2">"%PATH%;C_PATH</span><span class="se">\b</span><span class="s2">in"</span>
</code></pre></div></div>

<p>然后输入如下命令进行重启电脑</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown <span class="nt">-r</span> <span class="nt">-t</span> 0
</code></pre></div></div>

<hr />

<h3 id="linux">Linux</h3>

<p>这个还真是不太好整</p>

<p>就是各个系的Linux使用各自的包管理器安装编译工具链即可，然后什么都不用管了，记 <code class="language-plaintext highlighter-rouge">bin\gcc</code> 为 <code class="language-plaintext highlighter-rouge">C_PATH</code></p>

<hr />

<h3 id="官网下载">官网下载</h3>

<p><del>话说，我现在才说是不是有点坑人</del></p>

<h2 id="配置vscode">配置VScode</h2>

<h3 id="配置cc">配置C/C++</h3>

<p>按下 <code class="language-plaintext highlighter-rouge">Ctrl + Shift + X</code> ，打开拓展，搜索 <code class="language-plaintext highlighter-rouge">C/C++</code> ，然后下载官方的插件，然后写一个 <code class="language-plaintext highlighter-rouge">Hello World!</code> ，如下</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Hello World!"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span><span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果此时VScode右上角出现小箭头（运行），那么就让它自己配置，然后就可以使用了  <del>本文完</del></p>

<p>如果失败了，在项目文件夹根目录下新建一个叫 <code class="language-plaintext highlighter-rouge">.vscode</code> 的文件夹，创建一个叫 <code class="language-plaintext highlighter-rouge">tasks.json</code> 的文件，按照如下格式编写（我们使用 <code class="language-plaintext highlighter-rouge">G++</code> ，愿意使用 <code class="language-plaintext highlighter-rouge">GCC + 参数</code> 的自行修改）</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppbuild"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C/C++: g++.exe 生成活动文件"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C_PATH</span><span class="se">\\</span><span class="s2">g++.exe"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"-fdiagnostics-color=always"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"-g"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${file}"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"-o"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${fileDirname}</span><span class="se">\\</span><span class="s2">${fileBasenameNoExtension}.exe"</span><span class="w">
                </span><span class="err">//</span><span class="w"> </span><span class="err">其实就是编译参数，每个后面要有英文逗号</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${fileDirname}"</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"$gcc"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"调试器生成的任务。"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Q：这样的可以编译中文文件吗？</p>

<p>A：分情况，VScode不行，命令行行（使用MINGW）</p>

<p>比如：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-o</span> run.exe 你好.cpp <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-std</span><span class="o">=</span>c++17
</code></pre></div></div>

<p>就行，<del>就是不知道终端里怎么输入中文</del></p>

<p><strong>如果，你使用的是你以前IDE的编译器，请自己在C/C++里添加头文件路径！！！否则VScode会无端报错</strong></p>

<h3 id="推荐插件">推荐插件</h3>

<p>其实，插件这个东西，应该自己玩，但是吧，我还是想说一下语言翻译插件</p>

<p>以中文为例：同 <code class="language-plaintext highlighter-rouge">C/C++</code> 插件的安装方式，搜 <code class="language-plaintext highlighter-rouge">Chinese</code> 然后下载</p>

<hr />

<p>到此为止，VScode最基础的内容介绍完毕</p>]]></content><author><name>agppd</name></author><category term="技术" /><summary type="html"><![CDATA[大部分人入门一门语言大部分是通过IDE类的编译器入门的吧，显然，显示开发中，IDE的弊端明显（如：大部分IDE老旧，编译器更新困难），所以我们常使用文本编译器进行代码的编写，本文档主要讨论VScode的配置]]></summary></entry><entry><title type="html">Diskpart 使用基本教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E7%A8%8B/2026/02/25/diskpart.html" rel="alternate" type="text/html" title="Diskpart 使用基本教程" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E7%A8%8B/2026/02/25/diskpart</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E7%A8%8B/2026/02/25/diskpart.html"><![CDATA[<p>DiskPart 是 Windows 系统内置的一款强大的命令行磁盘管理工具。与图形化的“磁盘管理”界面相比，它提供了更灵活、更底层的控制能力，适用于磁盘分区、格式化、清理以及制作启动盘等高级任务。</p>

<h2 id="一启动-diskpart">一、启动 DiskPart</h2>
<p><strong>重要提示</strong>：DiskPart <strong>操作前务必备份重要文件</strong>，错误的操作可能导致数据永久丢失。</p>

<h3 id="1以管理员身份打开命令提示符">1：以管理员身份打开命令提示符</h3>
<p>由于 DiskPart 需要修改系统存储，必须使用管理员权限运行：</p>
<ol>
  <li>在 Windows 搜索框中输入 <code class="language-plaintext highlighter-rouge">cmd</code> 或 <code class="language-plaintext highlighter-rouge">命令提示符</code>。</li>
  <li>在搜索结果中，右键点击“命令提示符”，选择 <strong>“以管理员身份运行”</strong>。（或者直接 <code class="language-plaintext highlighter-rouge">Win + x + a</code> ）</li>
  <li>如果用户账户控制（UAC）提示，点击“是”。</li>
</ol>

<h3 id="2进入-diskpart-环境">2：进入 DiskPart 环境</h3>
<p>在命令行窗口中输入以下命令并回车：</p>
<pre><code class="language-cmd">diskpart
</code></pre>
<p>提示符会变成 <strong><code class="language-plaintext highlighter-rouge">DISKPART&gt;</code></strong>，此时你已经进入磁盘管理环境。</p>

<h2 id="二焦点的设置">二、焦点的设置</h2>
<p>DiskPart 的一个核心机制是 <strong>“焦点 (Focus)”</strong>。在执行操作（如清理、格式化）之前，必须先通过 <code class="language-plaintext highlighter-rouge">select</code> 命令将焦点对准某个具体的磁盘或分区。当前拥有焦点的对象就是后续命令的操作目标。</p>

<h2 id="三常用-diskpart-命令详解">三、常用 DiskPart 命令详解</h2>
<p>你可以在 <code class="language-plaintext highlighter-rouge">DISKPART&gt;</code> 提示符下输入 <code class="language-plaintext highlighter-rouge">help</code> 或 <code class="language-plaintext highlighter-rouge">？</code> 查看所有可用命令。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">命令</th>
      <th style="text-align: left">功能说明</th>
      <th style="text-align: left">示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">list disk</code></strong></td>
      <td style="text-align: left">列出计算机上所有物理磁盘。注意查看目标磁盘的编号（如 0、1、2），通常可以根据容量大小来判断哪个是你的 U 盘或新硬盘。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">list disk</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">select disk X</code></strong></td>
      <td style="text-align: left">选择编号为 X 的磁盘，将焦点设置给它。<strong>这是最关键的一步，请确保选对了磁盘。</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">select disk 1</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">list partition</code></strong></td>
      <td style="text-align: left">列出当前已选中磁盘上的所有分区。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">list partition</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">select partition Y</code></strong></td>
      <td style="text-align: left">选择编号为 Y 的分区，将焦点对准该分区。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">select partition 1</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">clean</code></strong></td>
      <td style="text-align: left"><strong>清空整个当前磁盘</strong>。它会删除磁盘上的所有分区和卷，使磁盘变为“未分配”状态。如果你想改变磁盘分区表格式（如从 MBR 转 GPT），通常会使用此命令。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">clean</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">create partition primary size=N</code></strong></td>
      <td style="text-align: left">在当前磁盘上创建主分区。<code class="language-plaintext highlighter-rouge">size=N</code> 的单位是 <strong>MB</strong>。如果不指定 size，则会将所有剩余空间创建为一个分区。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">create partition primary size=512000</code> （创建 500GB 主分区）</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">create partition extended</code></strong></td>
      <td style="text-align: left">创建扩展分区（用于 MBR 磁盘，以便在扩展分区内继续划分逻辑驱动器）。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">create partition extended</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">create partition logical</code></strong></td>
      <td style="text-align: left">在扩展分区内创建逻辑驱动器。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">create partition logical size=256000</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">format fs=NTFS/FAT32/exFAT quick</code></strong></td>
      <td style="text-align: left">格式化当前拥有焦点的分区。<code class="language-plaintext highlighter-rouge">fs=</code> 指定文件系统类型。建议加上 <code class="language-plaintext highlighter-rouge">quick</code> 参数进行快速格式化。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">format fs=NTFS quick</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">active</code></strong></td>
      <td style="text-align: left">将当前分区（主分区）标记为活动。这通常用于系统分区，告诉 BIOS 从这个分区引导启动。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">active</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">assign letter=D</code></strong></td>
      <td style="text-align: left">为当前分区分配一个驱动器号。如果不指定字母，系统会自动分配下一个可用的字母。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">assign letter=G</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">remove letter=D</code></strong></td>
      <td style="text-align: left">移除分区的驱动器号。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">remove letter=G</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><strong><code class="language-plaintext highlighter-rouge">exit</code></strong></td>
      <td style="text-align: left">退出 DiskPart 环境，返回命令提示符。</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">exit</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>agppd</name></author><category term="技术" /><category term="工程" /><summary type="html"><![CDATA[DiskPart 是 Windows 系统内置的一款强大的命令行磁盘管理工具。与图形化的“磁盘管理”界面相比，它提供了更灵活、更底层的控制能力，适用于磁盘分区、格式化、清理以及制作启动盘等高级任务。]]></summary></entry><entry><title type="html">C++模板分享——矩阵</title><link href="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/25/Matirx.html" rel="alternate" type="text/html" title="C++模板分享——矩阵" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/25/Matirx</id><content type="html" xml:base="http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A8%A1%E6%9D%BF/2026/02/25/Matirx.html"><![CDATA[<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span>
<span class="p">{</span>
    <span class="nl">private:</span>
    <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">mp</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
    <span class="nl">public:</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">x</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
        <span class="n">m</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">n</span><span class="o">=</span><span class="n">m</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="n">and</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">m</span> <span class="n">and</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="nf">query</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">x</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">unit</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">!=</span><span class="n">m</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"This is not a square. Check your init function. "</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">mp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mp</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for multiplication!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">p</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
                <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">*</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">mod</span><span class="p">)</span> <span class="n">sum</span> <span class="o">-=</span> <span class="n">mod</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot exponentiate non-square matrix!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Node</span> <span class="nf">result</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">result</span><span class="p">.</span><span class="n">unit</span><span class="p">();</span>
        <span class="n">Node</span> <span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">exp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">exp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
            <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span> <span class="o">||</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for addition!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Node</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span> <span class="o">||</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for subtraction!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">!=</span><span class="n">x</span><span class="p">.</span><span class="n">n</span> <span class="o">||</span> <span class="n">m</span><span class="o">!=</span><span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="k">operator</span> <span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="k">operator</span> <span class="o">-=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="k">operator</span> <span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Node</span> <span class="k">operator</span><span class="o">^</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for bitwise XOR!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">p</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">^</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Node</span> <span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for bitwise AND!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">p</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Node</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Matrix dimensions do not match for bitwise OR!"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="kt">size_t</span> <span class="n">p</span><span class="o">=</span><span class="n">x</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
        <span class="n">Node</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">p</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="k">operator</span> <span class="o">^=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">^</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="k">operator</span> <span class="o">&amp;=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="k">operator</span> <span class="o">|=</span><span class="p">(</span><span class="k">const</span> <span class="n">Node</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">|</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">input</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">prsize_t</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">size_t</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">mod</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>agppd</name></author><category term="数据结构" /><category term="模板" /><summary type="html"><![CDATA[```cpp class Node { private: size_t n,m; size_t mp[N][N]; public: Node(size_t x,size_t y) { n=x; m=y; memset(mp,0,sizeof(mp)); } Node() { n=0,m=0,memset(mp,0,sizeof(mp)); } Node(size_t x) { n=m=x;memset(mp,0,sizeof(mp)); } Node(const vector&lt;vector&gt;&amp; v) { if(v.empty()) { n = m = 0; memset(mp, 0, sizeof(mp)); return; } n = v.size(); m = v[0].size(); memset(mp, 0, sizeof(mp)); for(size_t i=0; i&lt;n and i+1&lt;N; i++) { for(size_t j=0; j&lt;m and j+1&lt;N; j++) { mp[i+1][j+1] = v[i][j]; } } } Node(const Node&amp; other) { n = other.n; m = other.m; memcpy(mp, other.mp, sizeof(mp)); } size_t query(size_t x,size_t y) { return mp[x][y]; } void unit() { if(n!=m) { cerr&lt;&lt;"This is not a square. Check your init function. "&lt;&lt;'\n'; return; } memset(mp,0,sizeof(mp)); for(size_t i=1;i&lt;=n;i++) mp[i][i]=1; return ; } Node&amp; operator=(const Node&amp; other) { if(this != &amp;other) { n = other.n; m = other.m; memcpy(mp, other.mp, sizeof(mp)); } return *this; } Node operator*(const Node &amp;x) const { if(m != x.n) { cerr &lt;&lt; "Matrix dimensions do not match for multiplication!" &lt;&lt; '\n'; return Node(); } size_t p=x.m; Node res(n,p); for(size_t i=1;i&lt;=n;i++) { for(size_t j=1;j&lt;=p;j++) { long long sum = 0; for(size_t k=1;k&lt;=m;k++) { sum += (1LL * mp[i][k] * x.mp[k][j]) % mod; if(sum &gt;= mod) sum -= mod; } res.mp[i][j] = sum % mod; } } return res; } void pow(long long k) { if(n != m) { cerr &lt;&lt; "Cannot exponentiate non-square matrix!" &lt;&lt; '\n'; return; } Node result(n); result.unit(); Node base = *this; long long exp = k; while(exp &gt; 0) { if(exp &amp; 1) result = result * base; base = base * base; exp &gt;&gt;= 1; } *this = result; } Node operator+(const Node &amp;x) const { if(n != x.n || m != x.m) { cerr &lt;&lt; "Matrix dimensions do not match for addition!" &lt;&lt; '\n'; return Node(); } Node res(n,m); for(size_t i=1;i&lt;=n;i++) { for(size_t j=1;j&lt;=m;j++) { res.mp[i][j] = (mp[i][j] + x.mp[i][j]) % mod; } } return res; } Node operator-(const Node &amp;x) const { if(n != x.n || m != x.m) { cerr &lt;&lt; "Matrix dimensions do not match for subtraction!" &lt;&lt; '\n'; return Node(); } Node res(n,m); for(size_t i=1;i&lt;=n;i++) { for(size_t j=1;j&lt;=m;j++) { res.mp[i][j] = (mp[i][j] - x.mp[i][j] + mod) % mod; } } return res; } bool operator==(const Node &amp;x) const { if(n!=x.n || m!=x.m) return false; for(size_t i=1;i&lt;=n;i++) { for(size_t j=1;j&lt;=m;j++) { if(mp[i][j]!=x.mp[i][j]) { return false; } } } return true; } void operator +=(const Node &amp;x) { *this = *this + x; } void operator -=(const Node &amp;x) { *this = *this - x; } void operator *=(const Node &amp;x) { *this = *this * x; }]]></summary></entry><entry><title type="html">虚拟机使用方法</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VMware.html" rel="alternate" type="text/html" title="虚拟机使用方法" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VMware</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/VMware.html"><![CDATA[<blockquote>
  <p>本文档处理虚拟机相关内容</p>
</blockquote>

<h2 id="1-常见的软件与下载">1. 常见的软件与下载</h2>

<p>点击链接了解详情（包括下载）</p>

<ol>
  <li>
    <p>Microsoft 的 <a href="https://learn.microsoft.com/zh-cn/windows-server/virtualization/hyper-v/get-started/Install-Hyper-V?tabs=powershell&amp;pivots=windows">Hyper-V</a>，本文档不做过多讲解</p>
  </li>
  <li>
    <p><a href="https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion">VMware WorkStation</a>，注意：不是 <code class="language-plaintext highlighter-rouge">VMware Player</code></p>
  </li>
  <li>
    <p><a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a></p>
  </li>
</ol>

<p>下载完成后直接进行安装</p>

<h2 id="2-vmware-workstation-相关">2. VMware WorkStation 相关</h2>

<p>前情提要：你需要自己准备相关的系统映像，没有的话，可以考虑一下<a href="https://msdn.itellyou.cn/">这个</a></p>

<p><strong>请确保你拥有所下载系统的合法授权。</strong></p>

<hr />

<h3 id="iso-安装">ISO 安装</h3>

<p>本质上，ISO安装其实就是引导ISO后，利用ISO自带的安装进行安装，所以安装的流程不进行讲解，只讲解如何配置</p>

<hr />

<h4 id="基础知识快捷键">基础知识：快捷键</h4>

<p>进入虚拟机：<code class="language-plaintext highlighter-rouge">Ctrl + G</code></p>

<p>退出虚拟机：<code class="language-plaintext highlighter-rouge">Ctrl + Alt</code></p>

<p>开关机可以使用上方工具栏的按钮，但是建议关机在系统内关机（卡死的情况下使用下面那一组的按钮，<strong>千万千万不要使用上面的</strong>）</p>

<hr />

<h4 id="快捷版无需处理iso内系统的安装">快捷版（无需处理ISO内系统的安装）</h4>

<ol>
  <li>文件(F) $\rightarrow$ 新建虚拟机(N)……    后打开界面</li>
  <li>选择 <code class="language-plaintext highlighter-rouge">典型（推荐）T</code></li>
  <li>选择第二个，并给出你ISO的绝对路径（如果你是实体光驱并用实体光盘的话，选第一个）</li>
  <li>选择你ISO里的系统（其实大部分随便选就行，很少会限制后面的硬件配置，限制了也能以后该）</li>
  <li>命名与虚拟机所有配置存放路径，自己选，不做说明</li>
  <li>然后进行设置硬盘大小，大小自己给，下面的取决于你是否需要映射硬盘（VMware WorkStation高于16的随便，因为映射不了），需要的话，建议选 <code class="language-plaintext highlighter-rouge">将虚拟硬盘存储为单个文件（O）</code></li>
  <li>需要修改硬件的话，点击 <code class="language-plaintext highlighter-rouge">自定义硬件</code> ，否则直接完成</li>
  <li>然后虚拟机就会自己开始安装东西，完成后即可使用</li>
</ol>

<p><strong>优点</strong>：快捷，方便</p>

<p><strong>缺点</strong>：可自定义化太弱</p>

<hr />

<h4 id="常规自己按照iso内的指导去安装">常规（自己按照ISO内的指导去安装）</h4>

<ol>
  <li><code class="language-plaintext highlighter-rouge">文件(F)</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">新建虚拟机(N)……</code>    后打开界面</li>
  <li>选择 <code class="language-plaintext highlighter-rouge">自定义（高级）C</code>，并配置兼容性（不要太低，最好 $\geq$ VM12）</li>
  <li>选择第二个，并给出你ISO的绝对路径（如果你是实体光驱并用实体光盘的话，选第一个）</li>
  <li>选择你ISO里的系统（其实大部分随便选就行，很少会限制后面的硬件配置，限制了也能以后该）</li>
  <li>命名与虚拟机所有配置存放路径，自己选，不做说明</li>
  <li>然后进行设置硬盘大小，大小自己给，下面的取决于你是否需要映射硬盘（VMware WorkStation高于16的随便，因为映射不了），需要的话，建议选 <code class="language-plaintext highlighter-rouge">将虚拟硬盘存储为单个文件（O）</code></li>
  <li>需要修改硬件的话，点击 <code class="language-plaintext highlighter-rouge">自定义硬件</code> ，否则直接完成</li>
  <li>然后按照ISO内安装完成顺利进入系统后，点击 <code class="language-plaintext highlighter-rouge">虚拟机（M）</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">安装VMware Tools（T）……</code> 后，看虚拟机最下方的提示，进行安装，最后记得弹出Tools的虚拟光盘</li>
</ol>

<p><strong>优点</strong>：完全</p>

<p><strong>缺点</strong>：没法自己安装</p>

<p>到此为止，最基础的系统安装已经完成</p>

<hr />

<h3 id="img-安装">IMG 安装</h3>

<blockquote>
  <p>注：IMG是很古早的软盘安装方式，一般情况下见不到，所以，你没办法一键安装，只能自己干</p>
</blockquote>

<hr />

<h4 id="常规自己按照iso内的指导去安装-1">常规（自己按照ISO内的指导去安装）</h4>

<ol>
  <li><code class="language-plaintext highlighter-rouge">文件(F)</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">新建虚拟机(N)……</code>    后打开界面</li>
  <li>选择 <code class="language-plaintext highlighter-rouge">自定义（高级）C</code>，并配置兼容性（不要太低，最好 $\geq$ VM12）</li>
  <li>选择第三个，后期要删除</li>
  <li>命名与虚拟机所有配置存放路径，自己选，不做说明</li>
  <li>然后进行设置硬盘大小，大小自己给，下面的取决于你是否需要映射硬盘（VMware WorkStation高于16的随便，因为映射不了），需要的话，建议选 <code class="language-plaintext highlighter-rouge">将虚拟硬盘存储为单个文件（O）</code></li>
  <li>需要修改硬件的话，点击 <code class="language-plaintext highlighter-rouge">自定义硬件</code> ，否则直接完成</li>
  <li>别着急开机，点击 <code class="language-plaintext highlighter-rouge">编辑虚拟机设置</code> ，点击 <code class="language-plaintext highlighter-rouge">CD/DVD（SATA）</code>，点击最下方的 <code class="language-plaintext highlighter-rouge">移除（R）</code>，然后点击旁边的 <code class="language-plaintext highlighter-rouge">添加（A）……</code> ，选择 <code class="language-plaintext highlighter-rouge">软盘驱动器</code> ，然后勾选 <code class="language-plaintext highlighter-rouge">启动时链接</code> ，并在下面选择软盘的绝对路径，然后点<strong>最右下角</strong>的 <code class="language-plaintext highlighter-rouge">确定</code> ，最后开机</li>
  <li>进入系统进行安装，安装完成后记得移除软盘驱动器。</li>
</ol>

<p>Q：为什么这个不安装 <code class="language-plaintext highlighter-rouge">VMware Tools</code> 了？</p>

<p>A：<code class="language-plaintext highlighter-rouge">VMware Tools</code> 大部分没有支持</p>

<p>是的，<code class="language-plaintext highlighter-rouge">Vmware Tools</code> 的支持是有限的，但是常见的Windows（Vista除外）与Linux发行版几乎都支持</p>

<hr />

<h3 id="从u盘安装">从U盘安装</h3>

<p>是的我们还可以通过U盘安装，其实，用这种方法都是嫌弃ISO自带的安装太慢，自己安装</p>

<p>虚拟机初始创建同 <code class="language-plaintext highlighter-rouge">从IMG安装</code> 但是，我们仅移除，不添加</p>

<ol>
  <li>点击 <code class="language-plaintext highlighter-rouge">虚拟机（M）</code> $\rightarrow$  <code class="language-plaintext highlighter-rouge">电源（P）</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">打开电源时进入固件（F）</code></li>
  <li>插入U盘，选择连接到虚拟机上，然后重启固件后并进入固件</li>
  <li>引导U盘，进入U盘</li>
  <li>然后怎么重装系统怎么来</li>
</ol>

<p>至此，<code class="language-plaintext highlighter-rouge">Vmware WorkStation</code> 的流程完成了</p>

<hr />

<h2 id="3-virtualbox-相关">3. VirtualBox 相关</h2>

<p><del>话说回来，安装好像需要　Microsoft Visual C++ 2019</del></p>

<hr />

<h3 id="安装">安装</h3>

<ol>
  <li>点击 <code class="language-plaintext highlighter-rouge">新建(N)</code></li>
  <li>按照指示填写内容（ISO就选ISO，IMG就选IMG）</li>
  <li>新建虚拟机完成后点击 <code class="language-plaintext highlighter-rouge">设置(S)</code> ，按照自己的需求修改引导顺序（UEFI就当这步不存在）</li>
  <li>开机，自己进行安装</li>
  <li>点击 <code class="language-plaintext highlighter-rouge">设置(S)</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">系统</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">处理器（P）</code> $\rightarrow$ 勾选 <code class="language-plaintext highlighter-rouge">启用PAE/NX</code></li>
  <li>开机后，点击 <code class="language-plaintext highlighter-rouge">设置</code> $\rightarrow$ <code class="language-plaintext highlighter-rouge">安装增强功能</code> ，然后按照提示安装</li>
</ol>

<p>Q：U盘呢，没啦？
A：作者正在寻找其进入固件的方法，等着吧。</p>

<p>至此，<code class="language-plaintext highlighter-rouge">Vmware WorkStation</code> 的流程完成了</p>

<hr />

<h2 id="4-sandbox相关">4. SandBox相关</h2>

<p>是的，如果实在不想下载并安装这些东西，我们还有补救办法——Windows 的 SandBox</p>

<p><del>家庭版的可以走了</del></p>

<hr />

<p>很简单，在Windows控制面板里，勾选 <code class="language-plaintext highlighter-rouge">启用SandBox</code>，重启后，便可以在开始菜单看到这个一次性的虚拟机</p>]]></content><author><name>agppd</name></author><category term="技术" /><summary type="html"><![CDATA[本文档处理虚拟机相关内容]]></summary></entry><entry><title type="html">C++模板分享——快读（火车头）</title><link href="http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/25/readandout.html" rel="alternate" type="text/html" title="C++模板分享——快读（火车头）" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/25/readandout</id><content type="html" xml:base="http://localhost:4000/%E6%A8%A1%E6%9D%BF/2026/02/25/readandout.html"><![CDATA[<blockquote>
  <p>本文发布已取得代码原作者同意</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">u32</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="n">_rbuf</span><span class="p">[</span><span class="mh">0x10000</span><span class="p">];</span>
<span class="k">struct</span> <span class="nc">stat</span> <span class="n">_rs</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">_rc</span><span class="p">;</span>

<span class="cp">#define init()\
do{\
memset(_rbuf,-1,0x40000);\
for(int i=48;i&lt;=57;++i) for(int j=48;j&lt;=57;++j) _rbuf[i&lt;&lt;8|j]=(j^48)*10+(i^48);\
fstat(0,&amp;_rs);\
_rc=(char*)mmap(NULL,_rs.st_size,1,2,0,0);}while(0)
</span>
<span class="cp">#define skip() do{while (*_rc&lt;33) _rc++;}while(0)
</span>
<span class="cp">#define gc() (*_rc++)
</span>
<span class="cp">#define _read4u(n)\
do{n=0;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
while (*_rc&gt;47) n=n*10+((*_rc++)^48);}while(0)
</span>
<span class="cp">#define _read8u(n)\
do{n=0;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
if (~_rbuf[*(uint16_t*)(_rc)]) n=n*100+_rbuf[*(uint16_t*)(_rc++)],++_rc;\
while (*_rc&gt;47) n=n*10+((*_rc++)^48);}while(0)
</span>
<span class="cp">#define _readu(n)\
do{for(n=0;~_rbuf[*(uint16_t*)(_rc)];++_rc) n=n*100+_rbuf[*(uint16_t*)(_rc++)];\
while (*_rc&gt;47) n=n*10+((*_rc++)^48);}while(0)
</span>
<span class="cp">#define _read4(n) do{int f=0;_rc+=f=*_rc==45;read4u(n);if (f) n=-n;}while(0)
#define _read8(n) do{int f=0;_rc+=f=*_rc==45;read8u(n);if (f) n=-n;}while(0)
#define _read(n) do{int f=0;_rc+=f=*_rc==45;readu(n);if (f) n=-n;}while(0)
</span>
<span class="cp">#define read4u(n) do{skip();_read4u(n);}while(0)
#define read8u(n) do{skip();_read8u(n);}while(0)
#define readu(n) do{skip();_readu(n);}while(0)
#define read4(n) do{skip();_read4(n);}while(0)
#define read8(n) do{skip();_read8(n);}while(0)
#define read(n) do{skip();_read(n);}while(0)
</span></code></pre></div></div>

<p>使用实例</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">u32</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">;</span>
    <span class="n">read4u</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;</span><span class="n">n</span><span class="o">--</span><span class="p">;){</span>
        <span class="n">read4</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">s</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>bcdmwSjy</name></author><category term="模板" /><summary type="html"><![CDATA[本文发布已取得代码原作者同意]]></summary></entry><entry><title type="html">套取数据教程</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/shujv.html" rel="alternate" type="text/html" title="套取数据教程" /><published>2026-02-25T00:00:00+08:00</published><updated>2026-02-25T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/shujv</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF/2026/02/25/shujv.html"><![CDATA[<p>首先，套取数据的使用场景是在输入和输出的数量都特别少的题（比如输入两个数，输出一个数）的题，这样的题可以套取数据 
那么，如何套取数据呢？</p>

<p>第一个方法：我们知道LOJ上的数据是公开的，所以，我们可以去LOJ上套取数据。（AT半公开）（大部分题都没有）</p>

<p>方法二：我们首先要知道一个特性，洛谷 RE 后会给你程序的返回值，我们可以利用这个特性，程序的返回值即main函数的返回值，所以，我们可以在主函数中return输入的数对255取模，例如</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>这样我们就知道了输入的 <code class="language-plaintext highlighter-rouge">n%255</code>。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="mi">255</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>这样我们就知道了输入的 <code class="language-plaintext highlighter-rouge">n ÷ 255</code> 。
我们如何获得输出数据呢？最简单的方法就是询问题解。此时，就有聪明的同学要问了，没有题解怎么办？首先，如果你的答案与标准答案不一样的话，就会返回不一样的值，例如在B4299中，我们使用以下代码：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"a"</span><span class="p">;</span> 
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>在第一个测试点中，就会得到<code class="language-plaintext highlighter-rouge"> read a, expected 2 </code>这样的结果我们就知道输出的第一个数的第一位为2
如果我们使用这份代码</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"2a"</span><span class="p">;</span> 
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>第一位就会显示<code class="language-plaintext highlighter-rouge">too long </code> 我们就知道第一个测试点为2如此重复，直到知道所有数据。</p>]]></content><author><name>WYZqaq</name></author><category term="技术" /><summary type="html"><![CDATA[首先，套取数据的使用场景是在输入和输出的数量都特别少的题（比如输入两个数，输出一个数）的题，这样的题可以套取数据 那么，如何套取数据呢？]]></summary></entry></feed>